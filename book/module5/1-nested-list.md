# ลิสต์ที่เก็บโครงสร้างข้อมูลอื่นอยู่

## ลิสต์ของลิสต์
ในการใช้งานจริงเราใช้ลิสต์ของลิสต์เพื่อเก็บข้อมูลประเภทเดี่ยวทั้ง 3 ประเภท ลิสต์ของลิสต์ของตัวเลข (ลิสต์ที่มีลิสต์ย่อยที่เก็บตัวเลข) ลิสต์ของลิสต์ของสตริง ลิสต์ของลิสต์ของบูลีน 

ขอยกตัวอย่างการใช้ลิสต์ของลิสต์ของตัวเลข ซึ่งเป็นลิสต์ของคะแนนของนักเรียน โดยแต่ละคะแนนจะประกอบไปด้วย คะแนนเก็บ คะแนนสอบกลางภาค และคะแนนสอบปลายภาค โดยเราจะเก็บคะแนนของนักเรียนแต่ละคนไว้ในลิสต์ของลิสต์ของตัวเลข ดังนี้
```python
scores = [
    [10, 20, 30],
    [40, 50, 60],
    [70, 80, 90]
]
```
เราสามารถเข้าถึงคะแนนของนักเรียนคนที่ 2 ได้ดังนี้
```python
scores[1]
```
ผลลัพธ์ที่ได้คือ
```python
[40, 50, 60]
```
ซึ่งเป็นลิสต์ของคะแนนของนักเรียนคนที่ 2

ลิสต์ของลิสต์มักจะใช้เก็บประโยคหลาย ๆ ประโยค เราจะเก็บประโยค 1 ประโยคไว้ในลิสต์ของสตริงคำ เมื่อเราต้องเก็บหลาย ๆ ประโยคจึงกลายมาเป็นลิสต์ของลิสต์ของสตริงคำ 
```python
[['I', 'want', 'you'], ['I', 'need', 'you'], ['I', 'love', 'you']]
```
ถ้าหากเรามีข้อมูลเป็นลิสต์ของสตริงที่เป็นประโยคภาษาอังกฤษ เราสามารถเปลี่ยนให้เป็นลิสต์ของลิสต์ของคำได้ดังนี้ 
```python
sentences = [
    'I want you',
    'I need you',
    'I love you'
]
words = [sentence.split() for sentence in sentences]
```

ในคำสั่งที่ใช้ list comprehension ในตัวอย่างโค้ดข้างต้น `sentence`  เป็นสตริง เราจึงสามารถใช้ `.split` ในการเปลี่ยนให้สตริง เป็นลิสต์ของคำโดยใช้ช่องว่างเป็นตัวแยก ผลลัพธ์ที่ได้คือ 
```python
[['I', 'want', 'you'], ['I', 'need', 'you'], ['I', 'love', 'you']]
```
ซึ่งเป็นลิสต์ของลิสต์ของสตริง

``````{admonition} คำถามชวนคิด
:class: note

สมมติว่าเรามีข้อมูลต่อไปนี้
```python
list_sen = [['แซม','ซื้อ','tv','ใหม่'],['android', 'ไม่', 'ได้','ถูก', 'กว่า', 'iphone']]
list_lang = [['th','th','en','th'],['en', 'th', 'th','th', 'th', 'en']]
list_lang2 = [[False, False, True, False], [True, False, False, False, False, True]]
list_len = [[3, 4, 2, 4], [7, 3, 3, 3, 4, 6]]
```
คำสั่งต่อไปนี้คืนค่าเป็นอะไร ซึ่งจัดเป็นข้อมูลประเภทใด
1. `list_sen[0]`
2. `list_lang[1][0]`
3. `list_lang2[1][2]`
4. `list_len[0][3]`

*เฉลย*
| คำสั่ง | คืนค่า | ประเภทข้อมูล | คำอธิบาย |
|:--------|:--------|:---------------|:---------|
| `list_sen[0]` | `['แซม','ซื้อ','tv','ใหม่']` | ลิสต์ของสตริง | `[0]`เข้าถึงข้อมูลในลิสต์ของลิสต์ของสตริง (`list_sen`) จึงแกะลิสต์ออกหนึ่งชั้น ได้~~ลิสต์ของ~~ลิสต์ของสตริง |
| `list_lang[1][0]` | `'en'` | สตริง | `[1]`เข้าถึงข้อมูลในลิสต์ของลิสต์ของสตริง (`list_lang`)จึงแกะลิสต์ออกหนึ่งชั้น ได้~~ลิสต์ของ~~ลิสต์ของสตริง จากนั้น `[0]` เข้าถึงสตริงในลิสต์ของสตริง ได้สตริง |
| `list_lang2[1][2]` | `False` | บูลีน | `[1]`เข้าถึงข้อมูลในลิสต์ของลิสต์ของบูลีน (`list_lang2`) จึงแกะลิสต์ออกหนึ่งชั้น ได้~~ลิสต์ของ~~ลิสต์ของบูลีน จากนั้น `[2]` เข้าถึงบูลีนในลิสต์ของบูลีน ได้บูลีน |
| `list_len[0][3]` | `4` | จำนวนเต็ม | `[0]`เข้าถึงข้อมูลในลิสต์ของลิสต์ของจำนวนเต็ม (`list_len`) จึงแกะลิสต์ออกหนึ่งชั้น ได้~~ลิสต์ของ~~ลิสต์ของจำนวนเต็ม จากนั้น `[3]` เข้าถึงจำนวนเต็มในลิสต์ของจำนวนเต็ม ได้จำนวนเต็ม |
``````

รูปแบบการใช้งานที่พบเห็นบ่อย ๆ ในการประมวลผลข้อมูล ได้แก่

- Iterate ไปบนสมาชิกทุกตัวที่อยู่ในลิสต์ย่อย
- รันฟังก์ชันไปบนสมาชิกทุกตัวที่อยู่ในลิสต์ย่อย
- การทำลิสต์ให้เรียบ (flatten) 

### Iterate ไปบนสมาชิกทุกตัวที่อยู่ในลิสต์ย่อย
สมมติว่าเราต้องให้นับจำนวนคำในประโยคที่เก็บไว้ในลิสต์ของลิสต์ของสตริง เราต้องใช้ for loop เพื่อไล่ลิสต์ย่อยออกมาทีละตัว และแต่ในลิสต์ย่อยเราต้องใช้ for loop อีกชั้นหนึ่งเพื่อไล่สตริงออกมาทีละคำ แปลออกมาเป็น pseudocode ได้ดังนี้
```python
for ลิสต์ย่อย in ลิสต์ใหญ่
    for ข้อมูลเดี่ยว in ลิสต์ย่อย
        ทำอะไรกับข้อมูลเดี่ยว
```

#### ตัวอย่าง
```python
sentences = [['I', 'want', 'you'], ['I', 'need', 'you'], ['I', 'love', 'you']]
total_words = 0
for sentence in sentences:
    for word in sentence:
        total_words += 1
print(total_words)
```
สิ่งที่ปรากฏบนหน้าจอ คือ
```python
9
```
ซึ่งเป็นจำนวนคำทั้งหมดในลิสต์ของลิสต์ของสตริง

โปรแกรมข้างต้นมีการใช้ for loop ซ้อนกัน (double for loop) โดยที่ for loop ชั้นนอกเป็นการไล่เอาสมาชิกแต่ละตัวที่เป็นลิสต์ออกมาจากลิสต์ของลิสต์ (`sentences`) โดยในแต่ละรอบให้ใช้ตัวแปร `sentence` มาใช้เก็บลิสต์ย่อย และ for loop ชั้นในเป็นการไล่เอาสมาชิกแต่ละตัวที่เป็นสตริงออกมาจากลิสต์ของสตริง (`sentence`) โดยในแต่ละรอบให้ใช้ตัวแปร `word` มาใช้เก็บสตริง และในแต่ละรอบให้นับคำที่อยู่ในตัวแปร `word` แล้วบวกเพิ่มในตัวแปร `total_words` ที่เป็นจำนวนคำทั้งหมด

#### ตัวอย่าง
สมมติว่าเราต้องการหาคำที่สะกดด้วยตัวอักษรภาษาอังกฤษทั้งหมดโดยไม่ต้องนับตัวซ้ำ ข้อมูลที่ได้มาถูกจัดเก็บอยู่ในลิสต์ของลิสต์ของสตริงคำ
```python
list_sen = [['แซม','ซื้อ','tv','ใหม่'],['android', 'ไม่', 'ได้','ถูก', 'กว่า', 'iphone']]
eng_word_set = set()
for sen in list_sen:
    for word in sen:
        if word.isalpha():
            eng_word_set.add(word)
```
 for loop ชั้นนอกเป็นการไล่เอาสมาชิกแต่ละตัวที่เป็นลิสต์ออกมาจากลิสต์ของลิสต์ (`list_sen`) โดยในแต่ละรอบให้ใช้ตัวแปร `sen` มาใช้เก็บลิสต์ย่อย และ for loop ชั้นในเป็นการไล่เอาสมาชิกแต่ละตัวที่เป็นสตริงออกมาจากลิสต์ของสตริง (`sen`) โดยในแต่ละรอบให้ใช้ตัวแปร `word` มาใช้เก็บสตริง และในแต่ละรอบให้ตรวจสอบว่าสตริงที่อยู่ในตัวแปร `word` เป็นสตริงที่มีแต่ตัวอักษรภาษาอังกฤษหรือไม่ โดยใช้ string method `.isalpha()` ซึ่งจะคืนค่าเป็นบูลีน ถ้าเป็นค่า `True` ให้เพิ่มสตริงที่อยู่ในตัวแปร `word` ลงในเซ็ต `eng_word_set` โดยใช้คำสั่ง `eng_word_set.add(word)` ซึ่งเป็นการเพิ่มสตริงลงในเซ็ต และเนื่องจากเราใช้เซ็ตในการเก็บ สตริงที่ซ้ำกันจะถูกลบออกไปโดยอัตโนมัติ

### รันฟังก์ชันไปบนสมาชิกทุกตัวที่อยู่ในลิสต์ย่อย

การรันฟังก์ชันไปบนสมาชิกทุกตัว เราเรียกว่าการทำ function mapping ให้ลองนึกทบทวนถึงการทำ function mapping กับลิสต์ที่ไม่มีการซ้อนลิสต์ จากตัวอย่างต่อไปนี้

สมมติว่า เราต้องการทำ function mapping ด้วยฟังก์ชันยกกำลังสองไปบนลิสต์ของตัวเลข `numbers = [2, 10, 12, 20]`(ซึ่งเป็นลิสต์ที่ยังไม่มีการซ้อนลิสต์) เริ่มจากการสร้างฟังก์ชัน `square` ที่รับตัวเลขเข้ามา แล้วคืนค่ากลับมาเป็นค่าที่ยกกำลังสอง
```python
def square(x):
    return x ** 2
```
เราอยากได้ผลลัพธ์จากการรัน `square` ไปทุกตัวบนลิสต์ `numbers`
```python
results = [square(2), square(10), square(12), square(20)]
``` 
หรือ
```python
results = [square(numbers[0]), square(numbers[1]), square(numbers[2]), square(numbers[3])]
```
แต่เนื่องจากเราไม่รู้ล่วงหน้าว่าลิสต์ `numbers` มีสมาชิกกี่ตัว เราจึงต้องเขียนโค้ดให้สามารถรัน `square` ไปบนสมาชิกทุกตัวของลิสต์ `numbers` ได้โดยไม่ต้องระบุจำนวนรอบของ for loop ไว้ล่วงหน้า เราจึงจำเป็นต้องใช้ function mapping ซึ่งมี 3 วิธี ดังนี้

1. Double for loop:
ใช้ for loop แล้วเก็บผลลัพธ์ไว้ในลิสต์ที่ขึ้นมาเตรียมไว้
    ```python
    results = []
    for ข้อมูลเดี่ยว in ลิสต์:
        ผลลัพธ์ = ฟังก์ชัน(ข้อมูลเดี่ยว)
        results.append(ผลลัพธ์)
    ```
    ตัวอย่าง เช่น
    ```python
    numbers = [2, 10, 12, 20]
    results = []
    for number in numbers:
        results.append(square(number))
    print(results)
    ```
    ผลลัพธ์ที่จะแสดงผลบนหน้าจอ คือ
    ```python
    [4, 100, 144, 400]
    ```
2. List comprehension
    ```python
    results = [ฟังก์ชัน(ข้อมูลเดี่ยว) for ข้อมูลเดี่ยว in ลิสต์]
    ```
    ตัวอย่าง เช่น
    ```python
    numbers = [2, 10, 12, 20]
    results = [square(number) for number in numbers]
    ```
3. `map` แล้วแปลงผลลัพธ์เป็นลิสต์
    ```python
    results = list(map(ฟังก์ชัน, ลิสต์))
    ```
    ตัวอย่าง เช่น
    ```python
    numbers = [2, 10, 12, 20]
    results = list(map(square, numbers))
    ```

เราสามารถใช้วิธีเหล่านี้ในทำนองเดียวกันเพื่อทำ function mapping กับลิสต์ของลิสต์

#### Double for loop 
โครงสร้างของการใช้ for loop เพื่อทำ function mapping จะต้องมีการใช้ for loop ซ้อน for loop ซึ่งมีโครงสร้างดังนี้
```python
results = []
for ลิสต์ย่อย in ลิสต์ใหญ่:
    sub_results = []
    for ข้อมูลเดี่ยว in ลิสต์ย่อย:
        ผลลัพธ์ = ฟังก์ชัน(ข้อมูลเดี่ยว)
        sub_results.append(ผลลัพธ์)
    results.append(sub_results)
```
จุดที่ซับซ้อนและน่าสังเกตคือ การสร้างลิสต์ย่อย `sub_results` ขึ้นมาเพื่อเก็บผลลัพธ์ที่ได้จากการทำ function mapping กับสมาชิกแต่ละตัวในลิสต์ย่อย ถ้าเราแกะเอา for loop ชั้นนอกออกเราก็จะเห็นว่าโครงสร้างนั้นเหมือนกับการทำ function mapping บนลิสต์ที่ไม่มีการซ้อนลิสต์ 
```python
    sub_results = []
    for ข้อมูลเดี่ยว in ลิสต์ย่อย:
        ผลลัพธ์ = ฟังก์ชัน(ข้อมูลเดี่ยว)
        sub_results.append(ผลลัพธ์)
```
แต่เพราะว่าเราต้องการทำ function mapping ไปบนลิสต์ย่อยทุกลิสต์ เราจึงต้องเอาโค้ดก้อนนี้ซ้อนเข้าไปใน for loop ชั้นนอก 1 ชั้น 

*ตัวอย่าง*

สมมติว่าเราต้องการหาความยาวของคำแต่ละคำในประโยคที่เก็บไว้ในลิสต์ของลิสต์ของสตริง เช่น ถ้าหาก input คือ
```python
words = [['แซม','ซื้อ','tv','ใหม่'],['android', 'ไม่', 'ได้','ถูก', 'กว่า', 'iphone']]
```
โปรแกรมจะต้องคืนค่ามาเป็นลิสต์ของลิสต์ของตัวเลข ซึ่งตัวเลขแต่ละตัวคือความยาวของคำในแต่ละตำแหน่ง
```python
[[4, 3, 2, 4], [7, 3, 3, 3, 4, 6]]
```
โจทย์ข้อนี้เราทราบแล้วว่าเราต้องมีการทำ function mapping โดยใช้คำสั่ง `len` ลงบนสมาชิกแต่ละตัวในลิสต์ย่อย ดังนั้นเราสามารถใช้โครงสร้าง double for loop มาประกอบกันได้ดังนี้
```python
words = [['แซม','ซื้อ','tv','ใหม่'],['android', 'ไม่', 'ได้','ถูก', 'กว่า', 'iphone']]
lengths = []
for sen in words:
    sub_lengths = []
    for word in sen:
        sub_lengths.append(len(word))
    lengths.append(sub_lengths)
print(lengths)
```

#### Nested list comprehension
เราสามารถใช้ list comprehension ซ้อนกัน (nested list comprehension) ในการทำ function mapping ได้ดังนี้
```python
results = [[ฟังก์ชัน(ข้อมูลเดี่ยว) for ข้อมูลเดี่ยว in ลิสต์ย่อย] for ลิสต์ย่อย in ลิสต์ใหญ่]
```
สังเกตว่าเราซ้อน expression `[ฟังก์ชัน(ข้อมูลเดี่ยว) for ข้อมูลเดี่ยว in ลิสต์ย่อย]` เข้าไปใน `[expression for ลิสต์ย่อย in ลิสต์ใหญ่]`

*ตัวอย่าง*
```python
words = [['แซม','ซื้อ','tv','ใหม่'],['android', 'ไม่', 'ได้','ถูก', 'กว่า', 'iphone']]
lengths = [[len(word) for word in sen] for sen in words]
print(lengths)
```

### การทำลิสต์ให้เรียบ (flatten) 
การทำลิสต์ให้เรียบ คือ การเปลี่ยนลิสต์ที่เคยเป็นลิสต์ซ้อนลิสต์ให้เป็นลิสต์ธรรมดาที่เก็บข้อมูลเดี่ยวไว้ ในกรณีที่ข้อมูลที่เราได้รับมาเป็นข้อมูลที่มีโครงสร้างที่ซับซ้อนเกินไปอย่างลิสต์ของลิสต์ของคำซึ่งเก็บข้อมูลระดับประโยคไว้ด้วยว่ามีประโยคอยู่กี่ประโยค (ลิสต์ย่อย) และแต่ละประโยคมีคำอยู่กี่คำ (สตริงที่อยู่ในลิสต์ย่อย) หากเราไม่ต้องการข้อมูลในระดับประโยคเราอาจจะย่อลงให้เหลือเพียงลิสต์ของสตริงคำ โดยการทำลิสต์ให้เรียบ

โครงสร้างของโค้ดที่ใช้ในการทำลิสต์ให้เรียบ จะมีการใช้ for loop ซ้อน for loop ซึ่งมีโครงสร้างดังนี้
```python
results = []
for ลิสต์ย่อย in ลิสต์ใหญ่:
    for ข้อมูลเดี่ยว in ลิสต์ย่อย:
        results.append(ข้อมูลเดี่ยว)
```
หรือ จะใช้ list comprehension ซ้อนกัน (nested list comprehension) ในการทำลิสต์ให้เรียบ ดังนี้
```python
results = [ข้อมูลเดี่ยว for ลิสต์ย่อย in ลิสต์ใหญ่ for ข้อมูลเดี่ยว in ลิสต์ย่อย]
```
สังเกตว่าโครงสร้าง nested list comprehension แบบนี้มีลักษณะคล้ายคลึงกับ การทำ function mapping บน nested list ซึ่งมีโครงสร้างดังนี้
```python
results = [[ฟังก์ชัน(ข้อมูลเดี่ยว) for ข้อมูลเดี่ยว in ลิสต์ย่อย] for ลิสต์ย่อย in ลิสต์ใหญ่]
``` 
ข้อแตกต่าง คือ expression ที่ใช้ในการทำลิสต์ให้เรียบมีอยู่ตำแหน่งเดียวเท่านั้น และไม่มีการใช้ฟังก์ชันใด ๆ ในการประมวลผลข้อมูล แต่ว่า nested list comprehension สำหรับ function mapping จะมี expression สำหรับ for loop ชั้นนอกคือ `[ฟังก์ชัน(ข้อมูลเดี่ยว) for ข้อมูลเดี่ยว in ลิสต์ย่อย]` ซึ่งให้ค่าเป็นลิสต์ และ expression สำหรับ for loop ชั้นในคือ `ฟังก์ชัน(ข้อมูลเดี่ยว)` 

ข้อแตกต่างของโครงสร้างอีกอย่างคือ nested list comprehension สำหรับทำให้ลิสต์ให้เรียบ จะมีการใช้ for loop ชั้นนอกก่อน และ for loop ชั้นในทีหลัง แต่สำหรับ function mapping จะมีการใช้ for loop ชั้นในก่อน และ for loop ชั้นนอกหลัง

![illustration of the structures](img/nopic.jpg)

*ตัวอย่าง*
```python
words = [['แซม','ซื้อ','tv','ใหม่'],['android', 'ไม่', 'ได้','ถูก', 'กว่า', 'iphone']]
flattened_word_list = [word for sen in words for word in sen]
print(flattened_word_list)
```
ผลลัพธ์ที่ได้คือ
```python
['แซม', 'ซื้อ', 'tv', 'ใหม่', 'android', 'ไม่', 'ได้', 'ถูก', 'กว่า', 'iphone']
```

## ลิสต์ของทูเปิล
ทูเปิลเป็นโครงสร้างข้อมูลที่เหมาะกับการเก็บข้อมูลหนึ่งหน่วยที่มีหลายมิติ เช่น พิกัด 1 พิกัด มีค่า x และ y ซึ่งเป็นตัวเลข 2 ค่า เช่น
```python
coordinate = (3, 4)
```
หรือ คน 1 คน มีชื่อ และนามสกุล และชื่อเล่นซึ่งเป็นสตริง 3 สตริง เช่น
```python
person_name = ('เศรษฐา', 'ทวีสิน', 'นิด')
```

เราใช้ลิสต์ของทูเปิลเวลาเราต้องการเก็บพิกัดหลาย ๆ พิกัด หรือชื่อนักเรียนหลาย ๆ คน เช่น
```python
coordinates = [(3, 4), (5, 6), (7, 8)]
names = [('เศรษฐา', 'ทวีสิน', 'นิด'), ('ประยุทธ์', 'จันทร์โอชา', 'ตู่'), ('ยิ่งลักษณ์', 'ชินวัตร', 'ปู'), ('อภิสิทธิ์', 'เวชชาชีวะ', 'มาร์ค')]
```
ถ้าหากเราต้องการให้โค้ดดูอ่านง่ายขึ้น เราควรจัดรูปให้สมาชิกแต่ละตัวของลิสต์อยู่แยกบรรทัดกัน
```python
coordinates = [
    (3, 4),
    (5, 6),
    (7, 8)
]
names = [
    ('เศรษฐา', 'ทวีสิน', 'นิด'),
    ('ประยุทธ์', 'จันทร์โอชา', 'ตู่'),
    ('ยิ่งลักษณ์', 'ชินวัตร', 'ปู'),
    ('อภิสิทธิ์', 'เวชชาชีวะ', 'มาร์ค')
]
```
เมื่อเราแจกแจงโครงสร้างดังโค้ดข้างต้น เราจะสังเกตได้ว่าข้อมูลที่เก็บอยู่ในตัวแปร `names` มีลักษณะดังนี้
- โครงสร้างข้อมูลชั้นนอกสุดเป็นลิสต์ เพราะว่าข้อมูลถูกครอบอยู่ด้วย `[]` 

- โครงสร้างข้อมูลชั้นในที่เป็นสมาชิกแต่ละตัวของลิสต์เป็นทูเปิล เพราะว่าข้อมูลถูกครอบอยู่ด้วย `()` 

- ข้อมูลเดี่ยวชั้นในสุดเป็นสตริงเพราะมีการใช้ `''` 

`````{admonition} คำถามชวนคิด
:class: note

สมมติว่าเรามีข้อมูลต่อไปนี้
```python
cities = [(37.774929, -122.419418), (13.756331, 100.501762)]
```
คำสั่งต่อไปนี้คืนค่าเป็นอะไร
1. `cities[0]`
2. `cities[1][0]` 

*เฉลย*
| คำสั่ง | คืนค่า | ประเภทข้อมูล | คำอธิบาย |
|:--------|:--------|:---------------|:---------|
| `cities[0]` | `(37.774929, -122.419418)` | ทูเปิล | `[0]`เข้าถึงข้อมูลในลิสต์ของทูเปิล (`cities`) จึงแกะลิสต์ออกหนึ่งชั้น ได้ทูเปิล 
| `cities[1][0]` | `13.756331` | float | `[1]`เข้าถึงข้อมูลในลิสต์ของทูเปิล (`cities`) จึงแกะลิสต์ออกหนึ่งชั้น ได้ทูเปิล จากนั้น `[0]` เข้าถึงจำนวนเต็มในทูเปิล ได้จำนวนเต็ม |
``````

### Iterate บนลิสต์ของทูเปิล
เราสามารถ iterate บนลิสต์ของทูเปิลได้ด้วยวิธีเดียวกันกับการ iterate บนลิสต์ของข้อมูลประเภทอื่น ๆ โดยใช้ for loop เช่นเดิม ดังนี้
```python
for ทูเปิล in ลิสต์ของทูเปิล:
    ทำอะไรกับทูเปิล
```
สมมติว่าเรามีลิสต์ของพิกัดละติจูดและลองจิจูดของเมือง และเราต้องการสร้างอีกลิสต์เพื่อเก็บเฉพาะเมืองที่อยู่ซีกโลกตะวันตก โดยใช้ for loop ดังนี้
```python
cities = [(37.774929, -122.419418), (13.756331, 100.501762)]
western_cities = []
for city in cities:
    if city[1] < 0:
        western_cities.append(city)
```
หรือใช้ list comprehension
```python
cities = [(37.774929, -122.419418), (13.756331, 100.501762)]
western_cities = [city for city in cities if city[1] < 0]
```

เวลาเรา iterate บนลิสต์ของทูเปิล ปัญหาที่เรามักจะพบคือเราอาจจะลืมว่าสมาชิกแต่ละตัวของทูเปิลเก็บค่าอะไรอยู่ เช่น เราอาจจะลิืมว่า `city[0]` เก็บละติจูดหรือลองจิจูด ทำให้เราเขียนโปรแกรมผิดพลาดได้ง่าย ด้วยเหตุนี้เรานิยม unpack tuple หรือกระจายค่าแต่ละค่าของทูเปิลแยกออกมาเก็บไว้ในตัวแปรแต่ละตัวก่อน แล้วจึงใช้ตัวแปรเหล่านั้นในการประมวลผลข้อมูล 

จากตัวอย่างข้างต้นเราควรแก้ไขโค้ดให้อ่านง่ายขึ้นด้วยการกระจายค่าของทูเปิลออกมาเก็บไว้ในตัวแปรแต่ละตัวก่อน ดังนี้
```python
cities = [(37.774929, -122.419418), (13.756331, 100.501762)]
western_cities = []
for city in cities:
    lat, lon = city
    if lon < 0:
        western_cities.append((lat, lon))
```
หรือกระจายค่าของทูเปิลออกมาเก็บไว้ในตัวแปรใน for loop โดยไม่ต้องสร้างแปรมาเก็บทูเปิลเลย
```python
cities = [(37.774929, -122.419418), (13.756331, 100.501762)]
western_cities = []
for lat, lon in cities:
    if lon < 0:
        western_cities.append((lat, lon))
```

หรือใช้ list comprehension
```python
results = [expression for ตัวแปร1, ตัวแปร2, ... , ตัวแปร n in ลิสต์ของทูเปิล]
```
เราสามารถแก้ไขโค้ดเป็น
```python
cities = [(37.774929, -122.419418), (13.756331, 100.501762)]
western_cities = [(lat,lon) for lat, lon in cities if lon < 0]
```
หากเราต้องการ unpack tuple เราต้องทราบจำนวนสมาชิกของทูเปิลที่อยู่ในลิสต์ และทูเปิลทุกตัวที่อยู่ในลิสต์จะต้องมีจำนวนสมาชิกเท่ากัน 
ถ้าหากจำนวนตัวแปรที่เราใช้น้อยกว่าจำนวนสมาชิกของทูเปิล จะเกิดความผิดพลาดขึ้น และถ้าหากจำนวนตัวแปรที่เราใช้มากกว่าจำนวนสมาชิกของทูเปิล จะเกิดความผิดพลาดขึ้นเช่นกัน
```python
cities = [(37.774929, -122.419418), (13.756331, 100.501762)]
western_cities = []
for city in cities:
	latitude, longitude, height = city
	if longitude < 0:
		western_cities.append(city)
```
เราจะได้ผลลัพธ์เป็น
```python
ValueError: not enough values to unpack (expected 3, got 2)
```
เนื่องจากเรา unpack tuple ไปยังตัวแปรสามตัวแปร แต่ว่าสมาชิกของทูเปิลมีเพียงสองตัว ภาษาไพธอนไม่อะลุ่มอล่วยให้ `height` เป็นค่า `None` เพื่อให้โปรแกรมไหลไปได้ จึงแจ้ง `ValueError` ออกมา 

หากทูเปิลแต่ละตัวมีจำนวนสมาชิกที่แตกต่างกัน 
```python
cities = [(37.774929, -122.419418, 100), (13.756331, 100.501762)]
western_cities = []
for city in cities:
	latitude, longitude, height = city
	if longitude < 0:
		western_cities.append(city)
```
เราจะได้ผลลัพธ์เป็น error ที่มีข้อความแจ้งขึ้นมาเหมือนกัน
```python
ValueError: not enough values to unpack (expected 3, got 2)
```
เพราะว่าเมื่อเรา iterate ไปถึงทูเปิล `(13.756331, 100.501762)` จำนวนตัวแปรมีสามตัว แต่ว่าสมาชิกของทูเปิลมีสองตัวเท่านั้น 

จากโค้ดข้างเราสังเกตได้ว่าค่าของ `latitude` ไม่ได้ถูกใช้ในการประมวลผลข้อมูลเลย แต่เราจำเป็นต้องสร้างตัวแปรเข้ามารองรับค่าทุกค่าของทูเปิล ในกรณีดังกล่าวเรามักจะตั้งชื่อตัวแปรที่ไม่ได้ใช้เป็น `_` เพื่อบ่งบอกว่าตัวแปรนั้นตั้งมาเพื่อรับค่าไม่ให้เกิด error เฉย ๆ แต่ไม่ได้นำไปประมวลผลต่อ ดังนั้นเราสามารถแก้ไขโค้ดจากตัวอย่างเป็น 
```python
cities = [(37.774929, -122.419418), (13.756331, 100.501762)]
western_cities = []
for city in cities:
    _, longitude = city
    if lon < 0:
        western_cities.append(city)
```
จากตัวอย่างทั้งหมดนี้ทำให้เห็นว่าการเขียนโค้ดเพื่อประมวลผลข้อมูลที่มีความซับซ้อนมากขึ้่นมีอยู่หลายวิธี นอกจากเราต้องเขียนโค้ดให้ประมวลผลได้ผลลัพท์ถูกต้องแล้ว เรายังต้องคำนึงถึงว่าโค้ดที่เราเขียนนั้นจะอ่านง่ายและเข้าใจได้ง่าย โดยไม่ต้องใช้เวลานานในการอ่านโค้ด และไม่ต้องใช้เวลานานในการหาข้อผิดพลาดที่เกิดขึ้นในโค้ด

## ลิสต์ของดิกชันนารี
ลิสต์ของดิกชันนารีเป็นโครงสร้างข้อมูลอีกประเภทที่พบเห็นได้บ่อย เราอาจจะสงสัยกันว่าเมื่อไรกันที่เราต้องการเก็บรายการของสิ่งที่เก็บคู่ key value เอาไว้เยอะ ๆ ดิกชันนารีที่ถูกเก็บอยู่ในลิสต์มักจะเป็นดิกชันนารีที่มี key เหมืิอนกันทุกตัว ดิกชันนารีประเภทนี้มีหน้าที่คล้ายคลึงกับทูเปิล เช่น หากว่าเราใช้ลิสต์ของทูเปิลในการเก็บข้อความและผู้ส่งข้อความดังนี้
```python
messages = [
    ('โกโก้', 'แม่เป็นกำลังใจของหนู')
    ('โกโก้', 'หนูมีแม่คนเดียว'), 
    ('คริส', 'ทุกคนมีแม่คนเดียวโกโก้')
    ]
```
การเก็บข้อมูลในลักษณะนี้อาจทำให้เกิดข้อผิดพลาดได้ตรงที่เราอาจจะลืมว่าเราเก็บชื่อคนพูดไว้ในตำแหน่งใดของทูเปิล ในกรณีเราอาจจะใช้ดิกชันนารีแทนได้เพื่อความชัดเจน
```python
messages = [
    {'speaker': 'โกโก้', 'message': 'แม่เป็นกำลังใจของหนู'}, 
    {'speaker': 'โกโก้', 'message': 'หนูมีแม่คนเดียว'}, 
    {'speaker': 'คริส', 'message': 'ทุกคนมีแม่คนเดียวโกโก้'}
    ]
```
โดยผิวเผินแล้วการเก็บข้อมูลทั้งสองวิธีนั้นเก็บข้อมูลได้ครบถ้วนเหมือนกัน ให้ลองเปรียบเทียบโค้ดในการแสดงผลข้อความให้ดูเป็นบทสนทนา
```python
for m in messages:
    print(f'{m[0]}: {m[1]}')
```
กับ
```python   
for m in messages:
    print(f'{m["speaker"]}: {m["message"]}')
```
จากตัวอย่างข้างต้นเราสามารถสังเกตได้ว่าการใช้ดิกชันนารีทำให้โค้ดอ่านง่ายขึ้น และเราไม่ต้องคอยจำลำดับของข้อมูลในทูเปิล แต่ก็มีข้อควรระวังคือ ดิกชันนารีทุกตัวที่อยู่ในลิสต์จะต้องมี key ที่เหมือนกันหมด มิฉะนั้นเราจะต้องเขียนโค้ดเพิ่มเติมเพื่อตรวจสอบว่าดิกชันนารีมี key ที่ต้องการเข้าถึงหรือไม่ ซึ่งอาจจะทำให้โค้ดดูซับซ้อนเกินความจำเป็น

ดิกชันนารีที่เราใช้ลักษณะดังตัวอย่างข้างต้น จะมี key ที่เป็นสตริงที่เป็นฟิลด์ (field) บ่งบอกว่าข้อมูลที่เป็น value เป็นข้อมูลอะไร เช่น ดิกชันนารีในตัวอย่างข้างต้นมี 2 ฟิลด์ คือ `speaker` และ `message` ซึ่งบ่งบอกว่า value ของดิกชันนารีคือผู้พูด และข้อความที่คนนั้นพูด เราขอเรียกดิกชันนารีที่มี key เป็นฟิลด์ว่าเป็น field-value dictionary

ตัวอย่างที่แล้วอาจจะยังไม่ได้ทำให้เห็นภาพว่าทำไมเราถึงจำเป็นต้องใช้ field-value ดิกชันนารี ให้ลองพิจารณากรณีที่เราต้องเก็บทวีตจำนวนมาก
```python
[ {'id': 'BarackObama', 'date': 'October 17, 2019', 'num comments': 243000,
  'num retweets': 37200, 'num fav': 250300, 'text': 'I was proud to work with Justin Trudeau as President'},
 {'id': 'SpeakerPelosi', 'date': 'October 17, 2019', 'num comments': 22700,
  'num retweets': 10000, 'num fav': 45600, 'text': 'What courage does it take to pass legislation that will save lives?'},
 {'id': 'BarackObama', 'date': 'October 15, 2019', 'num comments': 2000,
  'num retweets': 5400, 'num fav': 52800, 'text': 'In December, Michelle and I will head to Malaysia for the first @ObamaFoundation Leaders: Asia-Pacific gathering'}
]
```
ดิกชันนารีที่เราใช้ในตัวอย่างข้างต้นเป็น field-value ดิกชันนารี ที่มีฟิลด์ดังต่อไปนี้
- `id` บ่งบอกว่าทวีตนั้นมาจากบัญชีใคร
- `date` บ่งบอกว่าทวีตนั้นถูกโพสต์เมื่อวันที่ไหน
- `num comments` บ่งบอกว่าทวีตนั้นมีคอมเมนต์กี่คอมเมนต์
- `num retweets` บ่งบอกว่าทวีตนั้นถูก retweet กี่ครั้ง
- `num fav` บ่งบอกว่าทวีตนั้นทำให้เป็น favorite โดยการกดปุ่มหัวใจบนแอปกี่ครั้ง
- `text` บ่งบอกว่าทวีตนั้นมีข้อความอะไร

สมมติต่ออีกว่าเราต้องการเขียนโปรแกรมเพื่อหาว่าแต่ละคนถูก retweet ทั้งหมดกี่ครั้ง
```python
import collections
counter = collections.Counter()
for tweet in tweet_list:
  twitter_id = tweet['id']
  retweets = tweet['num retweets']
  counter[twitter_id] += retweets
print(counter.most_common())
```
ผลลัพธ์ที่ได้คือ
```python
[('BarackObama', 42600), ('SpeakerPelosi', 10000)]
```
ถ้าหากเราต้องการทำเหมือนกันด้วยการใช้ลิสต์ของทูเปิล โค้ดจะมีความซับซ้อนขึ้น และอ่านยากขึ้น อย่างแรกคือผู้เขียนโค้ดจะต้องไปตามหาว่า twitter id และจำนวนการ retweet อยู่ในตำแหน่งใดของทูเปิล ทำให้เกิดความยุ่งยากในการเขียนโค้ด เมื่อเขียนเสร็จแล้วโค้ดจะยากต่อการอ่าน ดังที่เห็นในโปรแกรมข้างล่างนี้
```python
counter = collections.Counter()
for tweet in tweet_list:
  twitter_id = tweet[0]
  retweets = tweet[3]
  counter[twitter_id] += retweets
```
หากเราต้องกลับมาอ่านโค้ดของเราเอง เราก็อาจจะลืมไปแล้วว่าตำแหน่งที่ 0 และ 3 เก็บอะไรไว้อยู่ หรือถ้าส่งต่อให้คนอื่นในทีมเพื่อตรวจสอบหรือเขียนโค้ดต่อจากเรา ก็ยากต่อการทำความเข้าใจด้วยเหตุผลเดียวกัน ปัญหาอีกประการหนึ่งคือ ถ้าหากเพิ่มข้อมูลเข้าไปในทูเปิลก็อาจจะทำให้ตำแหน่งที่เก็บเปลี่ยนไปได้ เนื่องจากทูเปิลเป็นโครงสร้างข้อมูลแบบมีลำดับ จากตัวอย่างนี้ทำให้เห็นว่าถ้าหากข้อมูลหนึ่งตัวเก็บข้อมูลอยู่หลายอย่างในลักษณะคล้ายกับกับการกรอกฟอร์มที่มีหลาย ๆ ฟิลด์ การใช้ field-value ดิกชันนารีเป็นวิธีที่ดีกว่าการใช้ทูเปิล

## สรุป
ลิสต์ของลิสต์ ลิสต์ของทูเปิล ลิสต์ของดิกชันนารีเป็นโครงสร้างข้อมูลที่ชั้นนอกสุดคือลิสต์ที่มีหน้าที่เก็บข้อมูลที่มีลักษณะคล้ายกัน เช่น ลิสต์ที่เก็บข้อมูลเดี่ยวประเภทเดียวกัน ทูเปิลที่มีจำนวนสมาชิกเท่ากัน และข้อมูลเดี่ยวประเภทเดียวกัน ดิกชันนารีที่มี key เหมือนกัน เป็นการเพิ่มกรณีการใช้งานของลิสต์จากที่เราเคยใช้เก็บข้อมูลเดี่ยว เพิ่มมาเป็นการเก็บข้อมูลแบบคอลเลกชัน