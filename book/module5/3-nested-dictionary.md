# ดิกชันนารีที่เก็บโครงสร้างข้อมูลอื่นอยู่


## ดิกชันนารีที่ key เป็นทูเปิล


```{figure} img/dict-tuple.jpeg
---
height: 100px
align: center
---
ภาพอธิบายโครงสร้างของดิกชันนารี
```

จากภาพจะเห็นได้ว่าเรามีทูเปิลของสตริงสองตำแหน่งไว้เก็บชื่อและชื่อเล่น มีดิกชันนารีรูปแบบที่เคยพบในบทก่อน ๆ คือมี key เป็นสตริง และมีดิกชันนารีรูปแบบใหม่ที่มี key เป็นทูเปิล

หากเราต้องการดิกชันนารีไว้เก็บข้อมูลชื่อคนแล้วพบกรณีที่บางคนชื่อซ้ำกัน เช่น มีคนชื่อ ```อรรถพล``` 2 คน การใช้ดิกชันนารีรูปแบบเดิมที่มี key เป็นสตริงในการเก็บข้อมูลโดยเพิ่มสมาชิกใหม่เข้าไปจะทำให้ key value เดิมถูกเขียนทับไป เนื่องจาก key ในดิกชันนารีห้ามซ้ำกัน 

ดังนั้นดิกชันนารีที่มี key เป็นทูเปิลจึงเป็นทางแก้ปัญหานี้ ทำให้เราสามารถใส่ข้อมูลสมาชิกได้เพิ่มขึ้น จากตัวอย่างคือเปลี่ยนรูปแบบดิกชันนารีจากที่มี key เป็นสตริงไว้เก็บชื่ออย่างเดียว ให้เป็นดิกชันนารีที่มี key เป็นทูเปิลไว้เก็บสตริงสองตัวเป็นชื่อกับชื่อเล่นเพื่อเลี่ยงการที่มี key ซ้ำกัน


ในการเก็บข้อมูลทำสมุดโทรศัพท์มีตัวอย่างโครงสร้างข้อมูลแบบต่าง ๆ  ดังนี้ 

```python
entry_list = [ ('Mark', 'Wahlberg', '111-222-3333'),
  ('Jane', 'Doe', '222-333-4444'),
  ('Jane', 'Eyre', '333-444-5555')
]

friend_to_phone = { ('Mark', 'Wahlberg') : '111-222-3333',
  ('Jane', 'Doe'): '222-333-4444',
  ('Jane', 'Eyre'): '333-444-5555'
}
```
ตัวแปร ```entry_list``` มีโครงสร้างข้อมูลเป็นลิสต์ของทูเปิลโดยที่ทูเปิลเก็บข้อมูลชื่อ นามสกุล และเบอร์โทรเป็นสตริง ตัวแปร ```friend_to_phone``` มีโครงสร้างข้อมูลเป็นดิกชันนารีที่มี key เป็นทูเปิล และมี value เป็นสตริง

### Grab all phone numbers
หากเราต้องการเปิดหาเบอร์โทรทั้งหมดที่มีอยู่จะได้ดังนี้

สำหรับตัวแปร ```entry_list```

```python
phone_list = []
for first, last, phone in entry_list:
	phone_list.append(phone)
```
สำหรับตัวแปร ```friend_to_phone```

```python
phone_list = list(name_to_phone.values())
```



### Look up a phone number

หากเราต้องการสร้างฟังก์ชันสำหรับค้นหาเบอร์โทรของคน ๆ หนึ่งจากตัวแปรทั้งสองจะได้ดังนี้

```python
def find_mark_from_list(entry_list):
query = ('Mark', 'Wahlberg')
for entry in entry_list:
	first, last, phone = entry
	first_last = (first, last)
	if query == first_last: 
		return phone
```
`````{admonition} คำถามชวนคิด
:class: note


จากโปรแกรมข้างต้น ตัวแปรต่อไปนี้มี type เป็นอะไร
1. `entry`
2. `first` 

*เฉลย*

1. ทูเปิล 

2. สตริง 
``````
กับ

```python
def find_mark_from_dict(friend_to_phone):
    query = ('Mark', 'Wahlberg')
    return friend_to_phone[query]
```

จะเห็นได้ว่าตัวแปร ```friend_to_phone``` ที่มีโครงสร้างข้อมูลเป็นดิกชันนารีที่มี key เป็นทูเปิลสามารถเขียนฟังก์ชันค้นหาเบอร์โทรหรือเขียนดึงข้อมูลเบอร์โทรทั้งหมดได้ง่ายและกระชับกว่า ไม่ต้องทำการ unpack tuple ให้ซับซ้อนเหมือนกับการค้นเบอร์โทรหรือเขียนดึงข้อมูลเบอร์โทรทั้งหมดในตัวแปร ```entry_list```  ที่มีโครงสร้างข้อมูลเป็นลิสต์ของทูเปิล

นอกจากนี้ ดิกชันนารียังค้นหาเบอร์โทรได้รวดเร็วกว่าลิสต์ของทูเปิล จะเห็นได้ว่าในฟังก์ชันแรกมีการใช้ for loop ซึ่งจะทำให้ช้า เพราะต้องไล่หาทีละตัว โดยเฉพาะเมื่อมี entry จำนวนมาก แต่ในฟังก์ชันที่สองค้นหาเบอร์โทรจากดิกชันนารี สามารถค้นหา value จาก key ข้อมูลได้รวดเร็วโดยไม่ต้องคำถึงจำนวนสมาชิกในดิกชันนารี

แต่ในการใช้ดิกชันนารีเราก็ต้องตัดสินใจก่อนว่าจะค้นหาเบอร์โทรด้วยข้อมูลอะไร จากตัวอย่างจะเป็นการใช้ชื่อนามสกุลในการค้นหา จึงใช้ทูเปิลของสตริงสองตัวที่เป็นชื่อและนามสกุลเป็น key  หากยังไม่รู้ว่าจะใช้ข้อมูลอะไรในการค้นหา ลิสต์ของทูเปิลอาจเป็นตัวเลือกที่ดีกว่า

## ดิกชันนารีที่ value เป็นลิสต์

การเก็บข้อมูลทำสมุดโทรศัพท์ในกรณีที่คนหนึ่งคนอาจมีเบอร์โทรศัพท์หลายเบอร์ด้วยโครงสร้างข้อมูลแบบลิสต์ของทูเปิลและดิกชันนารีที่มี value เป็นลิสต์ เขียนได้ดังนี้

```python
entry_list = [ ('Mark', 'Wahlberg', '111-222-3333', '444-555-6666'),
  ('Jane', 'Doe', '222-333-4444'),
  ('Jane', 'Eyre', '333-444-5555', '777-555-1111')
]

name_to_phone_list = { ('Mark', 'Wahlberg') : ['111-222-3333', '444-555-6666'] ,
  ('Jane', 'Doe'): ['222-333-4444'],
  ('Jane', 'Eyre'): ['333-444-5555', '777-555-1111']
}
```
### Get a list of phone numbers
การที่บางคนอาจมีเบอร์โทรศัพท์หลายเบอร์จะเป็นปัญหากับตัวแปร ```entry_list```  ที่เป็นลิสต์ของทูเปิลในการเปิดหาเบอร์โทรทั้งหมด เนื่องจากทูเปิลแต่ละตัวในลิสต์มีจำนวนสมาชิกไม่เท่ากัน จึงทำให้ไม่สามารถ unpack tuple แบบเดิมได้ ตัวแปร ```name_to_phone_list``` ซึ่งเป็นดิกชันนารีที่มี key เป็น tuple และมี value เป็นลิสต์ของสตริงที่เก็บข้อมูลเบอร์โทรจึงเป็นทางเลือกที่เหมาะสมในกรณีนี้

ตัวอย่างการเขียนโปรแกรมเพื่อค้นหาเบอร์โทรของคนหนึ่งคน
```python
results = []
first_last = ('Mark', 'Wahlberg')
phone_list = name_to_phone_list[first_last]
for phone in phone_list:
	results.append(phone)
```

จากโปรแกรมข้างต้นจะเป็นการค้นหาเบอร์โทรของ Mark Wahlberg จึงใช้ key `('Mark', 'Wahlberg')` ในการเข้าถึง value ซึ่งเป็นลิสต์ของสตริงที่เป็นเบอร์โทรด้วยคำสั่ง `name_to_phone_list[first_last]` จากนั้นใช้ for loop วนสตริงแต่ละตัวในลิสต์ของสตริงนั้นโดยใช้ตัวแปร `phone` มารับค่าสตริงและเพิ่มเข้าไปในลิสต์ผลลัพธ์ของเรา

เราจะได้ผลลัพธ์ลัพธ์ของ `results` เป็น
```python
['111-222-3333', '444-555-6666']
```

ในการปรับโค้ดให้เราสามารถเปิดค้นหาเบอร์ของทุกคนได้ เราจะใช้โครงสร้าง double for loop โดยเพิ่ม for loop ชั้นนอกเข้ากับโค้ดข้างบน ดังนี้ 
```python
results = []
first_last_list = list(name_to_phone_list.keys()) 
for first_last in first_last_list:
	phone_list = name_to_phone_list[first_last]
	for phone in phone_list:
		results.append(phone)
```
`````{admonition} คำถามชวนคิด
:class: note


จากโปรแกรมข้างต้น คำสั่งต่อไปนี้คืนค่าเป็น type อะไร
1. `name_to_phone_list[first_last]`
2. `list(name_to_phone_list.keys()) ` 

*เฉลย*

1. ลิสต์ของสตริง โดยที่สตริงเป็นเบอร์โทร

2. ลิสต์ของทูเปิล โดยที่ทูเปิลเป็นทูเปิลของสตริงสองตำแหน่งที่เป็นชื่อและนามสกุล
``````
ตัวแปร `first_last_list` ซึ่งเป็นลิสต์ของทูเปิลจะเก็บ key ทั้งหมดของดิกชันนารี `name_to_phone_list` ไว้ จากนั้น  for loop ชั้นนอกจะวนไปที่ลิสต์ของทูเปิลนี้ ใช้ตัวแปร `first_last` เก็บ key ของดิกชันนารีแต่ละตัวไว้ เพื่อนำไปใช้ในคำสั่ง `name_to_phone_list[first_last]` ในการเรียกคืนค่า value ที่เป็นลิสต์ของสตริงที่เก็บเบอร์โทรไว้ และเก็บไว้ในตัวแปร `phone_list` จากนั้นจะเข้าสู่ for loop ชั้นในเหมือนโปรแกรมก่อนหน้า

จากโปรแกรมทั้งหมด สามารถเขียนให้กระชับได้เป็น
```python
results = []
for first_last in name_to_phone_list:
	for phone in name_to_phone_list[first_last]:
		results.append(phone)
```
เนื่องจากเวลา for loop ไปบนดิกชันนารี สิ่งที่เราได้ออกมาจะเป็น key ดังนั้นจึงไม่จำเป็นต้องใช้คำสั่ง `list(name_to_phone_list.keys())` เพื่อทำลิสต์ของ key เหมือนโค้ดก่อนหน้า


## ดิกชันนารีที่ value เป็นดิกชันนารี
ในการเก็บข้อมูลทำสมุดโทรศัพท์บางทีเราอาจอยากได้ข้อมูลช่องทางติดต่ออื่น ๆ นอกจากเบอร์โทร การใช้ดิกชันนารีที่มี value เป็น field-value ดิกชันนารี โดยที่ value แต่ละตัวจะมี field ที่เหมือนกันทั้งหมด ทำให้เราสามารถเพิ่มช่องทางติดต่ออื่น ๆ ที่เราต้องการได้โดยง่าย เช่น ในตัวอย่างมี field ที่เป็น phone และ line

```python
name_to_info = { 
  ('Mark', 'Wahlberg') : {'phone': ['111-222-3333', '444-555-6666'] , 'line': 'itsmemark'},
  ('Jane', 'Doe'): {'phone': ['222-3333-44444'] , 'line': 'janehomegirl'}
  ('Jane', 'Eyre'): {'phone': ['333-444-5555', '777-555-1111'], 'line': 'eyesonme'}
}
```

`````{admonition} คำถามชวนคิด
:class: note


จากโปรแกรมข้างต้น คำสั่งต่อไปนี้คืนค่าเป็น type อะไร

1. `name_to_info[('Jane', 'Doe')]` 
2. `name_to_info[('Mark', 'Wahlberg')]['phone']`
3. `name_to_info[('Mark', 'Wahlberg')]['phone'][0]`
4. `name_to_info[('Jane', 'Eyre')]['address']`

*เฉลย*

| คำสั่ง | คืนค่า | ประเภทข้อมูล | คำอธิบาย |
|:----------|:--------|:---------------|:---------|
| `name_to_info[('Jane', 'Doe')]` | `{'phone': ['222-3333-44444'] , 'line': 'janehomegirl'}` | field-value ดิกชันนารี | `('Jane', 'Doe')`เป็น key เข้าถึงข้อมูลในดิกชันนารี (`name_to_info`) จึงได้ value ที่เป็น field-value ดิกชันนารี
| `name_to_info[('Mark', 'Wahlberg')]['phone']` | `['111-222-3333', '444-555-6666']` | ลิสต์ของสตริง | `('Mark', 'Wahlberg')`เป็น key เข้าถึงข้อมูลในดิกชันนารี (`name_to_info`) จึงได้ value ที่เป็น field-value ดิกชันนารี จากนั้น `['phone']` เป็น field จึงได้ value เป็นลิสต์ของสตริง |
| `name_to_info[('Mark', 'Wahlberg')]['phone'][0]` | `'111-222-3333'` | สตริง | `('Mark', 'Wahlberg')`เป็น key เข้าถึงข้อมูลในดิกชันนารี (`name_to_info`) จึงได้ value ที่เป็น field-value ดิกชันนารี จากนั้น `['phone']` เป็น field จึงได้ value เป็นลิสต์ของสตริง จากนั้น `[0]` เข้าถึงข้อมูลในลิสต์ของสตริง ได้สตริง  |
| `name_to_info[('Jane', 'Eyre')]['address']` | `KeyError` | - |  `('Jane', 'Eyre')`เป็น key เข้าถึงข้อมูลในดิกชันนารี (`name_to_info`) จึงได้ value ที่เป็น field-value ดิกชันนารี จากนั้นเพราะ `['address']` ไม่ได้เป็น field ใน field-value ดิกชันนารี จึงได้ `KeyError`  |
``````



### Bigram Count
ในการทำ Bigram Count หรือนับสองคำที่อยู่ติดกันในประโยค มีตัวอย่างโครงสร้างข้อมูลดังนี้

```python
bigram = { ('a', 'dog') : 1235,
  ('a', 'very') : 2356,
  ('in', 'the'): 6222,
  ('in', 'a'): 8533,
  ('in', 'here'): 233,
  ('in', 'my'): 551
}

bigram[('a', 'dog')]
```
เก็บข้อมูลเป็นดิกชันนารีที่มี key เป็นทูเปิลของสตริงสองตำแหน่งแสดงถึง Bigram และมี value เป็นตัวเลขแสดงถึงจำนวนครั้งที่พบ Bigram นั้น
การเข้าข้อมูลในโครงสร้างนี้จะเหมาะกับกรณีที่เรารู้ Bigram ที่เราต้องการค้นหาจำนวนครั้งแล้ว เพราะ key ที่ใช้ในการเข้าถึง value เป็นทูเปิลของสตริงสองตัวที่เป็น Bigram หากเรายังไม่รู้ Bigram ที่ชัดเจน แต่ต้องการรู้ว่าคำ ๆ นี้มีคำอะไรต่อตามมาบ้าง โครงสร้างข้อมูลต่อไปจะเหมาะสมกว่า

```python
bigram = { 'a': {'dog': 1235,
        'very' : 2356},
  'in': {'the' : 6222,
         'a'   : 8533,
         'here': 233,
         'my' : 551} 
}

bigram['in']['the']
```
เก็บข้อมูลเป็นดิกชันนารีที่มี key เป็นสตริงแสดงถึงคำแรกใน Bigram และมี value เป็นดิกชันนารีที่รวมคำทั้งหมดที่สามารถต่อท้ายคำแรกใน Bigram ได้ โดยที่ดิกชันนารีนี้ที่มี key เป็นสตริงแสดงถึงคำที่สองใน Bigram และ value เป็นตัวเลขแสดงถึงจำนวนครั้งที่พบ Bigram นั้น โครงสร้างข้อมูลลักษณะนี้นอกจากจะทำให้เรารู้จำนวนครั้งที่พบ Bigram แล้ว ยังทำให้เรารู้ได้ว่าคำ ๆ หนึ่งสามารถต่อท้ายด้วยคำว่าอะไรได้บ้าง เช่น หากอยากรู้ว่าคำว่า 'in' มีคำอะไรต่อท้ายได้บ้าง สามารถเขียนโปรแกรมได้ ดังนี้
```python
bigram['in']
```
จะได้ผลลัพธ์ออกมาเป็น
```python
{'the' : 6222,
  'a'   : 8533,
  'here': 233,
  'my' : 551} 
```


## สรุป
เนื้อหาบทนี้เราได้เรียนรู้เกี่ยวกับโครงสร้างข้อมูลของดิกชันนารีที่ซับซ้อนจากการที่มีประเภทของข้อมูลหลากหลายในส่วนของ key หรือ value ไม่ว่าจะเป็นดิกชันนารีที่มี key เป็นทูเปิล ดิกชันนารีที่มี value เป็นลิสต์ ดิกชันนารีที่มี value เป็นดิกชันนารี หรือดิกชันนารีที่มี value เป็น field-value ดิกชันนารี ซึ่งเป็นประโยชน์ในการนำไปใช้งานในหลายด้าน เราจะเห็นได้ว่าการค้นหาข้อมูลในดิกชันนารีจะสามารถเขียนโปรแกรมได้กระชับและรวดเร็วกว่าการค้นหาข้อมูลในลิสต์ และดิกชันนารีจะยังทำให้เราสามารถเก็บข้อมูลได้หลากหลายมากขึ้นขณะที่ยังสามารถค้นหาได้โดยง่ายต่างจากการใช้ทูเปิลยาว ๆ ในการเก็บข้อมูล
