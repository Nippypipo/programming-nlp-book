# File 

ไฟล์สามารถถูกแบ่งออกได้เป็น 2 ประเภท
1. ไฟล์ไบนารี (binary file) เป็นไฟล์ที่เราไม่สามารถเปิดอ่านเป็นตัวหนังสือได้ ข้อมูลถูกจัดเก็บรหัสประเภทอื่น ที่จะต้องใช้โปรแกรมเฉพาะเจาะจงในการเปิดอ่านและประมวลผล เช่น ไฟล์ภาพ ไฟล์เพลง ไฟล์ .docx ซึ่งต้องใช้โปรแกรม Microsoft Word ในการเปิดประมวลผล หรือ .xlsx ซึ่งต้องใช้โปรแกรม Microsoft Excel ในการเปิดประมวลผล ไฟล์เหล่านี้มีไลบรารีภาษาไพธอนที่สามารถใช้เปิดเพื่อนำข้อมูลมาประมวลผลได้เช่นกัน .zip ซึ่งต้องใช้โปรแกรมที่เปิดไฟล์ที่ถูกบีบอัดไว้ได้
2. ไฟล์ที่มนุษย์อ่านได้ (human-readable file) เป็นไฟล์ที่เก็บข้อความไว้สามารถใช้ IDE ในการเปิดอ่านได้โดยตรง ไฟล์เหล่านี้เป็นไฟล์ที่ไม่ได้เก็บอะไรไว้เลยนอกเหนือจากข้อความอย่างเดียว ในบทนี้เราจะรับมือกับไฟล์ประเภทนี้เพียงอย่างเดียว ตัวอย่างเช่น .html .js .csv .json 

ไฟล์ทั้งสองแบบมักจะมีนามสกุลของไฟล์ (file extension) เพื่อบ่งบอกว่าควรจะเปิดขึ้นมาใช้ได้อย่างไร เช่น .docx .xlsx .png เป็นต้น แต่ที่จริงแล้วเราสามารถตั้งนามสกุลไฟล์เป็นอะไรก็ได้ตามแต่ใจเรา แต่ถ้าไฟล์เป็นข้อความดิบล้วน ๆ เรามักจะตั้งว่าเป็น .txt 

ทั้งนี้การตั้งชื่อและสกุลของไฟล์นั้นไม่มีผลต่อตัวข้อมูลที่เก็บในไฟล์ใด ๆ ทั้งสิ้น แต่อาจจะทำให้เกิดความสับสน ถ้าเราจะตั้งสกุลของไฟล์ที่เก็บข้อความเป็น .mytext ก็สามารถทำได้และไม่ได้มีผลต่อข้อความที่เก็บอยู่ในไฟล์ แต่ก็จะไม่เป็นมาตรฐาน เมื่อส่งไฟล์ต่อให้คนอื่น ก็จะไม่ทราบแน่ชัดว่าไฟล์นั้นเก็บอะไรไว้อยู่ จะต้องเปิดด้วยวิธีใด หรือจะตั้งหลอกว่าเป็น .docx ก็ได้เช่นกัน แต่ว่าผู้ที่นำไฟล์ไปใช้ต่อก็อาจจะนำไปใช้ผิดวิธี พอเปิดด้วย Microsoft Word ก็อาจจะไม่ได้ หรือไม่ได้ผลตามที่ควรจะเป็น

ในบทนี้เราจะเรียนรู้คำสั่งที่ใช้ในการเปิดไฟล์โดยทั่วไป แต่จะเน้นไปที่ไฟล์ข้อความ (text file) เท่านั้นเพราะเป็นระบบที่ใช้ในการเก็บข้อมูลที่เป็นข้อความ (text data) อย่างเป็นสากล

## Pathname
พาธ (path) หรือชื่อพาธ (pathname) เป็นสตริงที่ไว้ระบุที่อยู่ของไฟล์ที่อยู่บนเครื่องของเรา เพื่อที่เราจะได้เขียนคำสั่งได้ถูกต้องว่าไฟล์ที่เราต้องการจะเปิดนั้นอยู่ที่ไหนบนเครื่อง หรือไฟล์ที่เราต้องการจะสร้างนั้นมีชื่อว่าอะไรอยู่ไหน


### Full path
พาธเต็ม (full path หรือ absolute path) คือการเขียนพาธแบบเต็ม ๆ ประกอบไปด้วย 3 ส่วนสำหรับ Windows และ 2 ส่วนสำหรับระบบปฏิบัติการ (Operating system: OS) MacOS และ Linux
1. (Windows เท่านั้น) ชื่อไดรฟ์ตามด้วยเครื่องหมาย : 
2. ชื่อโฟลเดอร์และโฟลเดอร์ย่อย ๆ คั่นด้วยเครื่องหมาย \ สำหรับ Windows และ / สำหรับ OS อื่น ๆ
3. ชื่อไฟล์ 

ตัวอย่าง (Windows)
| พาธเต็ม | ไดรฟ์ | โฟลเดอร์ | ชื่อไฟล์
|-----------|------|---------|--------
`C:\Downloads\data.zip` | C | `\Downloads` | `data.zip`
`C:\Documents\Prog NLP\example.ipynb` | C | `\Documents\Prog NLP` | `example.ipynb`

ตัวอย่าง (MacOS)
| พาธเต็ม | โฟลเดอร์ | ชื่อไฟล์
|-----------|---------|--------
`/Users/te/Downloads/data.zip` | `/Users/te/Downloads` | `data.zip`
`/Users/te/Prog NLP/example.ipynb` | `/Users/te/Prog NLP` | `example.ipynb`

### Relative path
การระบุพาธเต็มค่อนข้างยืดยาว พิมพ์แล้วมีโอกาสผิดสูง พาธสัมพัทธ์ (relative path) เป็นทางเลือกที่สะดวกกว่าเพราะว่าไม่จำเป็นต้องระบุพาธเต็ม ๆ พาธสัมพัทธ์จะใช้พาธของโฟลเดอร์ที่เรารันโค้ดมาต่อกันกับพาธสัมพัทธ์เพื่อให้กลายเป็นพาธแบบเต็ม เช่น ถ้าเรารันโค้ดที่โฟลเดอร์  `/Users/te/Prog NLP` และสั่งให้เปิดไฟล์ที่พาธสัมพัทธ์ `data/raw_text.zip` จะถูกแปลงให้กลายเป็น `/Users/te/Prog NLP/data/raw_text.zip` โดยอัตโนมัติ 

นอกจากนั้นเรายังสามารถระบุให้ถอยลงไปหนึ่งโฟลเดอร์หรือหลาย ๆ โฟลเดอร์ได้โดยการใช้ `..` เช่น ถ้าเรารันโค้ดที่โฟลเดอร์  `/Users/te/Prog NLP` 

| พาธสัมพัทธ์ | ถูกแปลงเป็นพาธเต็ม |
|-----------|---------|
|`../data/raw_text.zip`| `/Users/te/data/raw_text.zip`
|`../../data/raw_text.zip`| `/Users/data/raw_text.zip`
|`../../../data/raw_text.zip`| `/data/raw_text.zip`

## อ่านไฟล์ไล่ทีละบรรทัด
ไพธอนมีคำสั่ง `open()` เป็นฟังก์ชันบิวท์อินเพื่อใช้เปิดไฟล์ คำสั่งนี้ต้องการพาธเป็นพารามิเตอร์เพื่อระบุว่าจะเปิดไฟล์ใด และไฟล์นั้นอยู่ที่ไหน ซึ่งจะใช้พาธเต็มหรือพาธสัมพัทธ์ก็ได้

สมมติว่าเรามีไฟล์ชื่อว่า lydia.txt ซึ่งเป็นข้อมูลเนื้อเพลงที่เราขูดออกมาจากหน้าเว็บ จึงมีความไม่สมบูรณ์อยู่บ้าง
```
ไม่ว่างจริง ๆ
อะหรือว่า

มีคนอื่น
ต่อสายเธอทั้งคืน
ก็เจอแต่ฮืมฝากข้อความ
หาย

ไปเลย
```
เราสามารถใช้คำสั่ง `open` และ method `.readline` เพื่อแสดงผลบรรทัดที่มีข้อความอยู่ดังนี้
```python
song_file = open('lydia.txt')
for line in song_file:
	if line != '\n': # \n เป็นตัวอักขระลงท้ายบรรทัด
		print(line)
song_file.close()
```
ซึ่งจะแสดงผลดังนี้
```
ไม่ว่างจริง ๆ

อะหรือว่า

มีคนอื่น

ต่อสายเธอทั้งคืน

ก็เจอแต่ฮืมฝากข้อความ

หาย

ไปเลย

```
โปรแกรมตัวอย่างข้างบนใช้คำสั่ง `open` ซึ่งรีเทิร์นตัวอ่านไฟล์ จากนั้นเราจะสามารถลูปไปบนแต่ละบรรทัดที่อยู่ในไฟล์ซึ่งโปรแกรมจะมองหาสัญลักษณ์ `\n` (newline) ที่อยู่ในไฟล์เป็นจุดที่แบ่งบรรทัดในข้อความ และรีเทิร์นสตริงนำไปเก็บไว้ในตัวแปรเพื่อไปใช้ในลูปต่อไป  เมื่อเราเปิดไฟล์แล้วควรจะปิดไฟล์ทุกครั้ง เนื่องจากเมื่อเราเปิดไฟล์แล้ว ระบบจัดการไฟล์ของเครื่องคอมพิวเตอร์ของเราอาจจะล็อคไฟล์ๆ นั้นไว้ เพื่อป้องกันไม่ให้โปรแกรมมาเขียนทับในระหว่างที่เราอ่านอยู่ ดังตัวอย่างข้างบน เราปิดไฟล์ด้วย method `.close()`

สตริงที่ได้มาจากการลูปไปบนไฟล์จะลงท้ายด้วย `\n`เสมอเพราะว่าเป็นตัวแบ่งบรรทัด และคำสั่ง `print` จะเติม `\n` เข้าไปให้อีกตัวด้วย เพราะฉะนั้นในตัวอย่างข้างบนเราจะได้บรรทัดว่าง ระหว่างเนื้อร้องแต่ละวรรค (`\n\n` ติดกัน)

ถ้าหากอยากแสดงผลให้สวยงามขึ้น เราต้องใช้คำสั่ง `.strip()` เพื่อเอา `\n` ออกไปจากสตริงก่อนจะเรียก `print`
```python
song_file = open('lydia.txt')
for line in song_file:
	if line != '\n': # \n เป็นตัวอักขระลงท้ายบรรทัด
		print(line.strip())
song_file.close()
```
หรือเราจะลัดโดยการไม่เก็บตัวอ่านไฟล์ไว้ในตัวแปรเลยก็ได้
```python
for line in open('lydia.txt'):
	if line != '\n': # \n เป็นตัวอักขระลงท้ายบรรทัด
		print(line.strip())
```
ซึ่งจะแสดงผลดังนี้
```
ไม่ว่างจริง ๆ
อะหรือว่า
มีคนอื่น
ต่อสายเธอทั้งคืน
ก็เจอแต่ฮืมฝากข้อความ
หาย
ไปเลย
```


## เปิดไฟล์ด้วยคำสั่ง `with` 
วิธีนี้เป็นวิธีที่ปลอดภัยที่สุดในเปิดปิดไฟล์ เพราะเป็นการป้องกันการลืมปิดไฟล์ไปในตัว การใช้ `with` statement เป็นการจำกัดว่าเราจะใช้งานไฟล์นั้นจากจุดใดถึงจุดใด ตัวอย่าง เช่น 
```python
with open('lydia.txt') as songfile:
    for line in songfile:
        if line != '\n': # \n เป็นตัวอักขระลงท้ายบรรทัด
            print(line.strip())
```
สังเกตว่า `with` เป็นคำสงวนในภาษาไพธอน และบังคับให้เราใช้ไฟล์ได้ในเฉพาะ code block ที่อยู่ใต้ `with` เท่านั้นโค้ดที่ตามหลังมาจากนั้นจะไม่สามารถใช้ไฟล์นั้นได้อีกต่อไป เนื่องจาก `with` จะปิดไฟล์ให้โดยอัตโนมัติหลังจากรันโค้ดที่อยู่ใน code block นั้นเสร็จแล้ว หากเราพยายามอ่านจากไฟล์นั้นอีกจะได้ 
`ValueError: I/O operation on closed file.`

การเปิดปิดไฟล์ในวิธีนี้มีข้อดีคือ เราจำกัดตัวเราเองว่าเราสามารถอ่านหรือเปลี่ยนแปลงไฟล์ในช่วงโค้ดที่จำกัดทำให้เราไม่ลืมปิดไฟล์ และทำให้เรารู้ว่าไฟล์ถูกเปลี่ยนแปลงโดยส่วนไหนของโค้ดของเราบ้าง 
## อ่านไฟล์และถ่ายข้อมูลทั้งหมดใส่สตริง: `.read()`
เราสามารถเก็บข้อมูลทั้งหมดในไฟล์ใส่สตริงโดยใช้ method `.read()`
```python
song_lyrics = open('lydia.txt').read()
print(song_lyrics)
```
ผลที่ได้ออกมาคือ
```
ไม่ว่างจริง ๆ
อะหรือว่า

มีคนอื่น
ต่อสายเธอทั้งคืน
ก็เจอแต่ฮืมฝากข้อความ
หาย

ไปเลย

```
คำสั่งนี้ค่อนข้างสะดวกถ้าเราต้องการประมวลผลข้อความทั้งไฟล์ โดยเฉพาะอย่างยิ่งเวลาเราต้องการขูดข้อมูลออกจากไฟล์จำนวนหลายไฟลฺ 
ข้อควรระวังคือ การใช้คำสั่งนี้เป็นการคัดลอกข้อมูลจากไฟล์ซึ่งอยู่ใน harddrive ของเครื่องคอมพิวเตอร์ซึ่งมักจะมีความจุมาก ๆ เช่น 250 gigabyte นำมาใส่หน่วยความจำชั่วคราว (RAM) ซึ่งมักจะมีความจุไม่มาก เช่น 16 gigabyte เพราะฉะนั้นเราใช้คำสั่ง `.read()` เป็นการนำข้อมูลทั้งหมดในไฟล์นั้นมาเก็บใส่ตัวแปรซึ่งเก็บข้อมูลไว้ใน RAM ถ้าไฟล์นั้นมีขนาดใหญ่กว่าหรือเทียบเท่าความจุของ RAM ของคอมพิวเตอร์เรา จะเกิดปัญหาเครื่องคอมพิวเตอร์ค้าง เนื่องจากหน่วยความจำถูกนำไปเก็บข้อมูลจากไฟล์ 

ถ้าหากไฟล์ที่ต้องการประมวลผลมีขนาดใหญ่ และมีหลายบรรทัด แนะนำให้ใช้ `for` ลูปเพื่อค่อยลำเลียงข้อมูลเข้ามาประมวลผลทีละบรรทัด หน่วยความจำ RAM ของเครื่องเก็บข้อมูลไว้แค่ทีละหนึ่งบรรทัดเท่านั้น พอประมวลผลเสร็จหนึ่งบรรทัด พื้นที่หน่วยความจำก็จะถูกแทนที่ด้วยข้อมูลจากบรรทัดถัดไป เช่นนี้ไปเรื่อย ๆ 

## อ่านไฟล์เพียงบางบรรทัด: `.readline()`
บางครั้งเราไม่ต้องการอ่านไฟล์ทั้งไฟล์ ทุกบรรทัด เราสามารถใช้ method `.readline()` ในการดึงข้อมูลออกมาทีละบรรทัด สมมติว่าเราต้องการเขียนโปรแกรมที่ประมวลผลเพียงสามบรรทัดแรกเท่านั้น
```python
with open('lydia.txt') as songfile:
    line1 = songfile.readline()
    line2 = songfile.readline()
print (line1)
print (line2)
```
ผลที่ได้ออกมาคือ
```
ไม่ว่างจริง ๆ

อะหรือว่า

```
ข้อสังเกตคือตัวเปิดไฟล์ (`songfile`) จะเก็บสถานะว่าเราอ่านไฟล์ไปถึงบรรทัดไหนแล้ว เมื่อเราเรียก `.readline` ครั้งต่อมาก็จะอ่านไฟล์ต่อจากการเรียก `.readline` ครั้งที่แล้ว 

เพราะฉะนั้นถ้าเราต้องการอ่านไฟล์แค่บรรทัดสุดท้าย เราต้องไล่อ่านตั้งแต่บรรทัดแรกไปจนถึงบรรทัดสุดท้าย เนื่องจากระบบจัดเก็บไฟล์ของเครื่องคอมพิวเตอร์ไม่ได้รองรับการจากท้ายไฟล์มายังต้นไฟล์ หรือการอ่านจากกลางไฟล์ การอ่านไฟล์ต้องเริ่มต้นจากต้นไฟล์ (ตัวอักษรตัวแรกของไฟล์) เท่านั้น 
## อ่านไฟล์และถ่ายข้อมูลทั้งหมดใส่ลิสต์: `.readlines()`
เราสามารถอ่านไฟล์แล้วเก็บใส่ลิสต์ที่สมาชิกแต่ละตัวเป็นข้อความแต่ละบรรทัดที่อยู่ในไฟล์ คำสั่งนี้เป็นการรวม `.read()` ซึ่งอ่านไฟล์ทั้งไฟล์จะย้ายมาเก็บในตัวแปร และ `.readline()` ซึ่งอ่านไฟล์โดยการแบ่งบรรทัด เพราะฉะนั้นมีข้อควรระวังในการใช้เหมือนการใช้ `.read` ก็คือห้ามเปิดไฟล์ที่มีขนาดใหญ่เกินไป เพราะเครื่องคอมพิวเตอร์อาจจะมีหน่วยความจำไม่พอในการเก็บข้อมูล
```python
lines = open('lydia.txt').readlines()
lines[0] #--> 'ไม่ว่างจริง ๆ\n'
lines[1] #--> 'อะหรือว่า\n'
```
## เขียนสตริงใส่ไฟล์ 
เมื่อเราประมวลผลข้อมูลเสร็จแล้ว เรามักจะต้องบันทึกข้อมูลจากสตริงลงไฟล์ โดยเฉพาะอย่างยิ่งถ้าสตริงเริ่มมีขนาดใหญ่เกินกว่าความจุของ RAM เราต้องทยอยถ่ายข้อมูลใส่ไฟล์ซึ่งอาศัยอยู่ใน hard drive ที่มีความจุมากกว่า RAM มาก ๆ 

วิธีการเขียนสตริงลงไฟล์ ให้เราเปิดไฟล์ขึ้นมาโดยระบุ `mode` เป็น `w` (write) แล้วใช้ method `.write` เช่น
```python
with open('my_fav_song.txt', mode='w') as f:
    f.write('ไม่ว่างจริง ๆ\n')
    f.write('อะหรือว่ามีคนอื่น\n')
```
ข้อควรระวังในการเขียนไฟล์มีดังนี้
1. อย่าลืมตั้ง `mode='w'` เพราะว่าโดย default ไพธอนจะเปิดไฟล์เพื่ออ่านไฟล์เท่านั้น ถ้าไม่ตั้งเป็นโหมดเขียน ไพธอนจะพยายามหาไฟล์นั้นเพื่อเปิดขึ้นมาอ่าน แต่ไฟล์นั้นไม่ได้มีอยู่ก่อนแล้ว เครื่องก็จะโยน `FileNotFoundError` มาให้ ซึ่งทำให้ยิ่งสับสนขึ้นไปอีก
2. เขียนได้เฉพาะสตริงเท่านั้น ถ้าพยายาม `.write` ตัวเลขหรือลิสต์ จะได้ `TypeError`
3. อย่าลืมใส่ `\n'` ถ้าหากต้องการแบ่งข้อความเป็นบรรทัด ไม่ยาวพืดเดียว
 
## เก็บดิกชันนารี หรือลิสต์ใส่ไฟล์โดยใช้ json
ถ้าข้อมูลของเราอยู่ในรูปของดิกชันนารี ลิสต์ ตัวเลข และสตริง เราสามารถจัดเก็บในรูปแบบของ json (อ่านว่า เจซอน หรือ เจสัน) ซึ่งจะแปลงโครงสร้างข้อมูลให้เป็นสตริง เพื่อที่จะนำเขียนลงไฟล์ในรูปแบบที่มนุษย์อ่านได้ 
ไพธอนมีไลบรารี json ที่มีฟังก์ชันที่ช่วยในการอ่านและเขียน json เช่น
```python
import json
lyrics = ['Lydia', 'ไม่ว่างจริง ๆ', 'หรือว่ามีคนอื่น', 'ต่อสายเธอทั้งคืน']
with open('my_fav_song.json', mode='w') as f:
    json.dump(lyrics, f)
```
เรามักจะตั้งสกุลของไฟล์เป็น .json เพื่อทำให้เราและคนอื่น ๆ ทราบว่าจะต้องเปิดไฟล์ด้วยวิธีใด ถ้าหากเราลองเปิดไฟล์โดยใช้ VSCode หรือ Notepad หรือ text editor ตัวอื่น ๆ เราจะเห็นไฟล์ดังนี้
```
["Lydia", "\u0e44\u0e21\u0e48\u0e27\u0e48\u0e32\u0e07\u0e08\u0e23\u0e34\u0e07 \u0e46", "\u0e2b\u0e23\u0e37\u0e2d\u0e27\u0e48\u0e32\u0e21\u0e35\u0e04\u0e19\u0e2d\u0e37\u0e48\u0e19", "\u0e15\u0e48\u0e2d\u0e2a\u0e32\u0e22\u0e40\u0e18\u0e2d\u0e17\u0e31\u0e49\u0e07\u0e04\u0e37\u0e19"]
```
ซึ่งดูแล้วไม่เหมือนกับไฟล์ที่มนุษย์อ่านได้เท่าไร เราจะอ่านออกเฉพาะตัวลาตินของภาษาอังกฤษ ที่จริงตัวหนังสือภาษาไทยถูกจัดเก็บในรูปของรหัส `\uXXXX` ซึ่งเครื่องจะใช้การถอดรหัสแบบ unicode ในการแปลว่า `0e44` คือ `ไ` โดยการเปิดหาในสมุดรหัสทีละตัว ที่เจซอนจัดเก็บข้อมูลแบบนี้โดย default เนื่องจากว่าในสมัยก่อนเครื่องคอมพิวเตอร์บางเครื่องสามารถอ่านหรือแสดงผลได้แค่ตัวอักษรแบบ ascii ซึ่งประกอบไปด้วยอักษรภาษาอังกฤษ ตัวเลข และเครื่องหมายวรรคตอนบางตัวเท่านั้น ไม่สามารถอ่านและแสดงผลตัวอักษรไทย emoji หรือตัวอักษรในระบบการเขียนอื่น ๆ ได้ 

ถ้าหากเราต้องการให้ไฟล์เจซอนสามารถอ่านตัวภาษาไทย หรือตัวอักษรประเภทอื่น ๆ ที่ไม่ใช่ตัวลาตินได้ เราต้องตั้ง `ensure_ascii=False` ซึ่งแปลว่าไม่ต้องจัดเก็บเป็นตัว ascii 
```python
import json
lyrics = ['Lydia', 'ไม่ว่างจริง ๆ', 'หรือว่ามีคนอื่น', 'ต่อสายเธอทั้งคืน']
with open('my_fav_song.json', mode='w') as f:
    json.dump(lyrics, f, ensure_ascii=False)
```
หากต้องการเปิดไฟล์ json ให้ใช้ `json.load`
```python
with open('my_fav_song.json') as f:
    lyrics = json.load(f)
```
วิธีนี้ได้ผลไม่ว่าตอนจัดเก็บเราจะจัดเก็บแบบ `ensure_ascii` ด้วยหรือไม่ เพราะเครื่องคอมพิวเตอร์ในปัจจุบันสามารถประมวลผล unicode ได้เป็นปกติ