# การคิดเชิงคำนวณ (Computational Thinking)
หลักสำคัญของการเขียนโปรแกรมไม่ใช่การจำคำสั่งให้ได้ แต่ว่าเป็นการนำคำสั่งมาประกอบรวมกันเพื่อสั่งให้เครื่องทำงานตามที่เราตั้งใจไว้ได้

เวลาเราได้โจทย์มาหนึ่งโจทย์ เช่น ดึงข้อมูล comment บนโลกโซเชียลลงมาเพื่อวิเคราะห์ว่าคนกำลังสนใจผู้สมัครผู้ว่าฯ คนไหนมากที่สุด จะเห็นว่าเป็นโจทย์ที่ใหญ่มาก ไม่รู้เลยว่าจะเริ่มจากตรงไหนก่อน หลัก Computational thinking เป็นหลักการที่ทำให้เราแก้โจทย์การเขียนโปรแกรมเหล่านี้ ซึ่งประกอบไปด้วย 4 หลัก

1. การย่อยโจทย์ (decomposition) คือ การพิจารณาโจทย์แล้วแจกแจงออกมาว่ามีโจทย์ย่อย ๆ อะไรบ้าง เช่น ถ้าเราต้องการประกอบตู้ลิ้นชักใส่เสื้อผ้า เราจะต้องย่อยเป็นการประกอบลิ้นชัก ประกอบโครงตู้ ประกอบขาตู้ และการประกอบส่วนต่าง ๆ มาเป็นส่วนเดียว
3. การหาแพทเทิร์นให้เจอ (pattern recognition) คือ การหาสิ่งที่โจทย์ย่อยนั้นมีเหมือน ๆ กัน เช่น ถ้าเราใช้ตัวอย่างการประกอบตู้ลิ้นชักใส่เสื่อผ้า โจทย์การประกอบตัวลิ้นชักเองมีแพทเทิร์นของมันอยู่ ก็คือเป็นกล่องที่เราต้องขันน็อตทั้งสี่ข้าง และต้องขันมือจับข้างหน้า ไม่ว่าจะเป็นลิ้นชักเล็กหรือใหญ่ ก็จะมีแพทเทิร์นการประกอบเหมือนกันอยู่ เพียงแต่เราต้องหามุมในการขันน็อตให้เจอ
2. การมองแบบนามธรรม (abstraction) คือ การแยกออกมาว่าแก่นสำคัญของโจทย์ทั้งหมดนั้นเป็นอย่างไร เช่น ลิ้นชักทั้งหมดที่มีขายอยู่ในท้องตลาดก็มีจะมีส่วนประกอบเหมือนกันหมด คือรูปทรงเป็นกล่องสี่เหลี่ยม ข้างบนเปิด มีที่จับสำหรับดึงออกมาได้ ซึ่งสิ่งเหล่านี้เป็นส่วนประกอบที่เป็นแก่นของโจทย์การประกอบลิ้นชัก แต่ว่าความกว้าง ความยาว วัสดุของลิ้นชักเอง หรือรูปร่างของหูจับจะเป็นอย่างไรนั้นเป็นรายละเอียดของตู้ลิ้นชักแต่ละยีห่้อ แต่ละขนาด แต่ละประเภท ซึ่งไม่ได้เป็นส่วนหนึ่งของแก่นของโจทย์
4. การออกแบบอัลกอริธึม (algorithm) คือกระบวนการแก้ปัญหาที่มีขั้นตอนชัดเจนจนสามารถสั่งให้เครื่องทำแทนเราได้ เช่น อัลกอริธึมของการประกอบตู้ลิ้นชักใส่เสื้อผ้า คือ 

```
1. ไล่ประกอบขาตู้ แล้วเอาพักไว้ก่อน
2. ประกอบโครงตู้ แล้วเอาพักไว้ก่อน
3. ประกอบผลลัพท์จาก 1 และ 2
4. ถ้าตู้มี k ลิ้นชัก ไล่ประกอบตัวลิ้นชักจนครบ k อัน
5. สอดลิ้นชักทั้ง k อันเข้าไปในโครงตู้
```
สังเกตว่าอัลกอริธึมข้างบนมีการย่อยโจทย์ออกมาเป็นส่วนๆ เพื่อแยกแก้ และมีการ abstraction ออกมาโดยไม่สนว่าลิ้นชักที่ต้องการประกอบนั้นจะมีกี่อันก็ตาม จะมีขนาดไหนก็ตาม อัลกอริธึมนี้ก็จะสามารถแก้ได้

## Karel 

ทักษะการคิดเชิงคำนวณดังตัวอย่างที่ยกขึ้นมานี้เป็นทักษะสำคัญที่สุดในการเขียนโปรแกรมซึ่งเราจะฝึกฝนกันในบทนี้โดยการใช้โปรแกรมที่ชื่อว่า Karel ตัว Karel เป็นหุ่นยนต์ตัวเล็ก ๆ เดินไปเดินมาในโลกสี่เหลี่ยมเล็ก ๆ เราสามารถเขียนภาษาไพธอนให้ Karel เดินไปตามคำสั่งของเรา เพื่อแก้โจทย์ต่าง ๆ ที่กำหนดได้ เราจะใช้ Karel เป็นของเล่นในการฝึก computational thinking ก่อนที่จะเร่ิมเขียนเป็นภาษาไพธอนจริง ๆ กับโจทย์จริง ซึ่งจะต้องจำคำสั่งเพ่ิมอีกมาก จุดประสงค์ของการเล่นกับ Karel ช่วยฝึกทักษะการคิดแบบนักเขียนโปรแกรมโดยที่ไม่ต้องจำคำสั่งมากมาย

Karel สามารถเดินไปข้างหน้าได้ทีละก้าว แต่ไม่สามารถทะลุกำแพงได้ ถ้าเดินชนกำแพงโปรแกรมจะเกิด error ซึ่งก็คือ Karel พัง โจทย์ในโลกของ Karel จะวาง Karel ไว้ที่จุดเริ่มต้น และกำหนดว่าโลกที่ให้มาขนาดเท่าไร มีกำแพงตรงไหนบ้าง และตัวกระดิ่ง (beeper) อยู่ตรงไหนบ้าง ซึ่ง Karel สามารถเก็บขึ้นมาหรือวาง beeper ตามจุดต่าง ๆ ได้ แต่ถ้าหากพยายามหยิบ beeper ในจุดที่ไม่มี beeper โปรแกรมก็จะเกิด error เช่นกัน คำสั่งที่ใช้ในการแก้โจทย์มีดังนี้

| คำสั่ง | คำอธิบาย |
|------|---------|
| `move()` |  ส่ังให้ Karel เดินไปข้างหน้า ถ้าข้างหน้ามีกําแพงมันจะชนและเกิด error |
| `turn_left()` |  สั่งให้ Karel เลี้ยวซ้าย |
| `put_beeper()` |  วางกระดิ่งหน่ึงอันไว้บนจุดท่ียืนอยู่ |
| `pick_beeper()` |  เก็บกระดิ่งข้ึนมาหน่ึงอันจากจุดท่ียืนอยู่ (ถ้าไม่มีกระดิ่งจะเกิด error |

สั่งการหุ่นยนต์ Karel ด้วยภาษาไพธอน 

```{image} img/karel-ex1.png
:height: 150px
:align: center
```
วิธีการแก้ดังนี้
```python
move()
pick_beeper()
turn_left()
move()
turn_left()
move()
put_beeper()
```

## โปรแกรม ฟังก์ชัน และการย่อยโจทย์
สมมติว่าเรามีโจทย์คือ ให้ Karel ไปหยิบ beeper ตรงหน้าเนินแล้วเดินข้ามเนินไปวาง beeper ที่คอลัมน์ที่ 5 ตามภาพข้างล่าง (ภาพซ้ายคือจุดเริ่มต้น ภาพขวาคือจุดมุ่งหมาย)

```{image} img/karel-ex2.png
:height: 150px
:align: center
```

เป็นโจทย์ที่ยังไม่ต้องคิดอะไรมากมาย สมมติเราเขียนโค้ดไพธอนเก็บไว้ในไฟล์ `my_karel_first.py` ดังนี้
```python
# โปรแกรมสำหรับแก้โจทย์แรกในบทนี้
from stanfordkarel import *

def main():
    move()
    pick_beeper()
    move()
    turn_left()
    move()
    turn_left()
    turn_left()
    turn_left()
    move()
    move()
    put_beeper()
    move()

if __name__ == "__main__":
    run_karel_program()
```
ส่วนประกอบของโปรแกรมในไฟล์นี้มีดังนี้

```python
# โปรแกรมสำหรับแก้โจทย์แรกในบทนี้
```
 ข้อความที่นำด้วย `#` เรียกว่า comment เขียนเอาไว้เพื่อให้คนอื่นมาอ่าน จะได้ทราบว่าโปรแกรมนี้ทำงานอย่างไร มีข้อควรรู้อะไรบ้าง เผื่อว่าคนอื่นอาจจะนำโปรแกรมของเราไปใช้ต่อ 

 ```python
`from stanfordkarel import *`
```
บอกให้โปรแกรมนี้ import ทุกคำสั่งมาจากไลบรารี `stanfordkarel` 

```python
def main():
    move()
    pick_beeper()
    move()
```
ส่วนนี้เรียกว่าฟังก์ชัน ลักษณะที่สำคัญของฟังก์ชันคือมี
- function header ซึ่งประกอบด้วย
  	- `def` เป็น keyword ที่ใช้สำหรับประกาศฟังก์ชันใหม่ 
	- ชื่อฟังก์ชันซึ่งตามมาหลัง `def` และตามด้วย `():`
- body ของฟังก์ชัน ซึ่งก็คือรายการคำสั่งต่าง ๆ ซึ่งจะต้องมีการย่อหน้า (indent) เข้ามาในทุกบรรทัด เพื่อบอกให้รู้ว่าคำสั่งใน body เป็นส่วนหนึ่งของฟังก์ชันนี้ 

```python
if __name__ == "__main__":
    run_karel_program()
```
ตรงส่วนนี้จะสั่งให้เริ่มต้นที่ฟังก์ชันชื่อ `main` และโหลดหน้าต่างที่มีตัว Karel แสดงผลอยู่ ส่วนนี้ของโปรแกรมเราอาจจะยังไม่เข้าใจทั้งหมด แต่ว่าให้ข้ามส่วนนี้ไปก่อน 

เราสังเกตอย่างแรกคือว่าโค้ดของเราค่อนข้างยาวและทำความเข้าใจได้ยาก เราต้องมานั่งวาดรูปและไล่ดูว่าแต่ละส่วนของโค้ดมีไว้ทำอะไร ซึ่งตรงนี้ทำให้เราแก้ไขโค้ดได้ยาก จัดว่าเป็นโค้ดที่ไม่ค่อยดี เราจะทำการสร้างฟังก์ชันขึ้นมาใหม่

ก่อน
```python
def main():
    move()
    pick_beeper()
    move()
    turn_left()
    move()
    turn_left() # <---แทนด้วยฟังก์ชันใหม่
    turn_left() #
    turn_left() #
    move()
    move()
    put_beeper()
    move()
```
หลัง
```python
def main():
    move()
    pick_beeper()
    move()
    turn_left()
    move()
    turn_right() # <---แทนด้วยฟังก์ชันใหม่
    move()
    move()
    put_beeper()
    move()

def turn_right():
	turn_left()
	turn_left()
	turn_left()
```
```{margin} คำศัพท์
การสร้างฟังก์ชัน (function defintion/declaration) คือ เขียนฟังก์ชันขึ้นมาใหม่ และตั้งชื่อของฟังก์ชันเพื่อให้พร้อมกับนำไปใช้

การเรียกฟังก์ชัน (function call) คือการนำฟังก์ชันที่เราได้สร้างไว้เรียบร้อยแล้วมาใช้
```
เราได้สร้างฟังก์ชันใหม่ขึ้น `turn_right()` ซึ่งทำให้โค้ดอ่านง่ายขึ้นเนื่องจากเราลดปริมาณโค้ดที่อยู่ในฟังก์ชัน `main` ลงไป 

เมื่อเราสร้างฟังก์ชันแล้ว เราสามารถเรียกฟังก์ชันนั้น (function call) จากฟังก์ชันอื่น ๆ ได้ วิธีการเรียกคือพิมพ์ชื่อของฟังก์ชันตามด้วย `()` ซึ่งขาดไม่ได้ ดังนั้นคำสั่ง`move()` หรือ `pick_beeper()` คือการเรียกฟังก์ชันเช่นเดียวกัน แต่ว่าฟังก์ชันเหล่านี้เราไม่ต้องตั้งขึ้นมาใหม่ เพราะเราได้ import เข้ามาแล้ว 

สรุปส่วนต่าง ๆ ของฟังก์ชันมีดังนี้
```{image} img/function.png
:height: 150px
:align: center
```

## ข้อควรระวัง
 การสร้างฟังก์ชันต้องมีรูปแบบตามที่ภาษาไพธอนกำหนดทุกประการ เครื่องคอมพิวเตอร์เป็นสิ่งที่ฉลาดแต่ว่าเราต้องสื่อสารกับคอมพิวเตอร์แบบถูกไวยากรณ์ทุกประการ ถ้าหากเราลืมอย่างใดอย่างหนึ่ง จะถือว่าผิดไวยากรณ์และ python interpreter จะโยน error (throw) มาให้เราตอนที่เราพยายามรันโค้ด และหยุดการรันโค้ดทันที เช่น 

 ```
   File "my_first_karel.py", line 5
    move()
       ^
IndentationError: expected an indented block
```
python interpreter โยน `IndentationError` มาให้ถ้าเราลืมกั้นย่อหน้าให้คำสั่ง `move()` ในบรรทัดที่ 5

```
  File "my_first_karel.py", line 4
    def main()
             ^
SyntaxError: invalid syntax
```
python interpreter โยน `SyntaxError` มาให้ถ้าเราลืม`:` ท้าย function header ในบรรทัดที่ 4 เพื่อแจ้งให้ทราบว่าเราเขียนโค้ดผิดไวยากรณ์ หรือถ้าเราลืม `()` ก็จะได้ `SyntaxError` เช่นกัน

```
  File "my_first_karel.py", line 4
    def main:
            ^
SyntaxError: invalid syntax
```
พอเราเรียนรู้การใช้คำสั่งใหม่ ๆ เพิ่มขึ้นเราจะเห็น error ชนิดต่าง ๆ เพิ่มขึ้น ซึ่งคนเขียนโปรแกรมควรจะอ่านเป็นว่า python interpreter พยายามนำอะไรมาฟ้องเราเพื่อให้เราแก้ไข ทำให้โค้ดทำงานได้ถูกต้อง 

## การคิดเชิงคำนวณเพื่อในการเขียนโปรแกรม
ทุกโจทย์การเขียนโปรแกรมที่เราได้มา เราต้องเริ่มจากการทำ decomposition ก่อน เพราะว่าโจทย์เล็กๆ หลายๆ อัน ง่ายกว่าการแก้โจทย์ใหญ่โจทย์เดียว ที่ง่ายกว่าก็เพราะว่าเราสามารถทดสอบ solution ของเราเป็นส่วน ๆ ได้ง่ายขึ้น 

ลองดูตัวอย่างโจทย์ว่า Karel ยืนอยู่บนถนนที่เป็นหลุมเป็นบ่อที่ต้องเอา beeper ลงไปอุดเพื่อทำให้ถนนเรียบ ๆ เดินง่าย สมมติว่าโลกที่ Karel เริ่มต้นเป็นแบบภาพซ้ายด้านล่าง พอเรารันโปรแกรมโดยสมบูรณ์แล้วจะออกมาหน้าตาเหมือนกับภาพขวาล่าง

```{image} img/repair-road.png
:height: 200px
:align: center
```
จริงๆ แล้วก็ยังเป็นโจทย์ที่ไม่ได้ยากซับซ้อนมากนัก Solution ที่เราได้มาโดยไม่อาศัยการคิดแบบการคิดเชิงคำนวณเลยจะออกมาประมาณนี้ (เราจะดูเฉพาะฟังก์ชัน `main` และ assume ว่าเราได้ import ไลบรารีต่าง ๆ และเก็บโค้ดลงในไฟล์ .py เป็นที่เรียบร้อยแล้ว)
```python
def main():
	move()
	turn_right()
	move()
	put_beeper()
	turn_right()
	turn_right()
	move()
	turn_right()
	move()
	move()
	move()
	# ไม่สมบูรณ์ยังมีต่ออีก...	
```
สังเกตอย่างแรกคือ เป็นโค้ดที่ยาวเหยียดมาก และเข้าใจได้ยากถ้าเราเลือกโค้ดขึ้นมาสักบรรทัด เราจะบอกไม่ได้เลยว่า ณ จุดนั้นแคเริลยืนอยู่ในไหนในโลก หันหน้าไปทางไหนอยู่ 

```{margin}
การย่อยโจทย์ เป็นขั้นตอนที่ 1 ของการคิดเขิงคำนวณ
```
เราจะลองแก้โจทย์นี้ใหม่อีกรอบโดยการใช้การย่อยโจทย์ โจทย์นี่้ที่จริงแล้วสามารถย่อยลงเป็น 3 โจทย์ย่อย
1. ซ่อมหลุมแรก
2. เดินไปหน้าหลุมไปที่สอง
3. ซ่อมหลุมที่ 2

เราจะแก้โจทย์ย่อยแต่ละโจทย์นี้โดยการใช้ฟังก์ชัน 3 ฟังก์ชันนี้ตามลำดับ
```python
def fill_hole1():
	pass

def move_to_next_hole()
	move()
	move()

def fill_hole2():
	pass
```
คำสั่ง `pass` ใส่ไว้เพื่อจองที่ไว้สำหรับการเขียนโค้ดจริงๆ สำหรับฟังก์ชันนั้น ในกรณีนี้เราเขียนโครงของฟังก์ชันทิ้งไว้ก่อนที่จะเริ่มลงรายละเอียดของแต่ละฟังก์ชันจริง ๆ 

```{margin}
การมองหาแพทเทิร์น เป็นขั้นตอนที่ 2 ของการคิดเขิงคำนวณ
```

แต่ถ้าเราสังเกตดูดี ๆ เราจะเห็นว่าโจทย์ที่ 1 กับโจทย์ที่ 3 เป็นโจทย์เดียวกัน เพราะเป็นแพทเทิร์นเดียวกัน ตามกรอบสีแดงข้างล่าง 

```{image} img/deposed-repair-road.png
:height: 200px
:align: center
```
เพราะฉะนั้นเราสามารถเรียกใช้ฟังก์ชันได้สองรอบ

```python
def main():
	fill_hole()
	move_to_next_hole()
	fill_hole()
	
def fill_hole():
	pass

def move_to_next_hole()
	move()
	move()
```
```{margin}
ยิ่งประหยัดโค้ดลงแค่ไหน ยิ่งทำให้ลดโอกาสที่จะเขียนโปรแกรมที่ผิดพลาดได้มากขึ้น
```
ฟังก์ชัน `main` ดูเรียบง่ายและเข้าใจง่ายกว่าของเดิมเยอะมาก เพราะเราย่อยโจทย์อกมาเป็นส่วนย่อย ๆ รวมกับการมองหาแพทเทิร์น ทำให้ปริมาณโค้ดที่เราต้องเขียนน้อยลงด้วย ทำให้เกิดข้อผิดพลาดน้อยลง

ตอนนี้เท่ากับว่าฟังก์ชันที่ต้องเขียนมีแค่ `fill_hole()` เท่านั้นที่เราจะนำไปใช้ถึง 2 ครั้งโดยที่เราเขียนฟังก์ชันนี้ขึ้นมารอบเดียว ฟังก์ชันนี้เรายังสามารถใช้หลักการย่อยโจทย์เพื่อย่อยลงไปได้อีก 

1. กระโดดลงไปในหลุม
2. วาง beeper
3. กระโดดออกมานอกหลุม

```{margin} คำศัพท์
implement แปลว่า เริ่มเขียนโค้ดจริงๆ หลังจากที่ได้มีคิดคำนวณ วางแผนไว้เรียบร้อยแล้ว ซึ่งตรงกับขั้นตอนที่ 4 ของการคิดเชิงคำนวณ
```
เราสามารถเริ่ม implement อัลกอริธึมได้เลย
```python
def fill_hole():
	jump_in()
	put_beeper()
	jump_out()

def jump_in():
	move()
	turn_right()
	move()

def jump_out():
	turn_around()
	move()
	turn_right()
	move()
```
โค้ดข้างบนนี้ทำให้เราเห็นแพทเทิร์นอีกอย่าง นั่นก็คือ `jump_in()` กับ `jump_out()` มีส่วนที่เหมือนกันอยู่ถึงสามบรรทัด นั่นก็คือ `move() turn_right() move()` นั่นก็คือการเดินเป็นรูปตัว L ทำให้เราสามารถเขียนฟังก์ชันมาใช้ซ้ำๆ ได้อีก

```python
def fill_hole():
	move_L()
	put_beeper()
	jump_out()

def move_L():
	move()
	turn_right()
	move()

def jump_out():
	turn_around()
	moveL()
```

ในการแก้โจทย์แคเริลซ่อมถนนข้อนี้ เราได้ใช้การย่อยโจทย์ การมองหาแพทเทิร์น และการเขียนอัลกอริธึม ซึ่งเป็น 3 ใน 4 ของหลักการคิดเชิงคำนวณ เราได้่ข้ามการมองแบบนามธรรมไปในโจทย์ข้อนี้ เราจะมาแก้โจทย์ที่ยากขึ้นเรื่อย ๆ ซึ่งเราจะเห็นต่อไปว่าขั้นตอนการมองแบบนามธรรมจะมีส่วนช่วยอย่างมาก 

```{margin} คำศัพท์
control flow เป็นลักษณะพิเศษของภาษาคอมพิวเตอร์ท่ีควบคุมลําดับการรันโปรแกรม ว่าบรรทัดไหนเกิดก่อนหลัง ก่ีคร้ัง
```
## Control flow - `for` loop
โปรแกรมที่เราเขียนมาทั้งหมดถึงตอนนี้รันโค้ดจากบรรทัดแรกไปถึงบรรทัดสุดท้าย โดยอาจจะมีการกระโดดไปรันฟังก์ชันย่อยอื่น ๆ บ้าง แต่ว่าก็รันเรียงลำดับจากบรรทัดแรกไปบรรทัดสุดท้าย ภาษาคอมพิวเตอร์มีสิ่งที่เรียกว่า control flow ซึ่งก็คือคำสั่งที่พิเศษที่ทำให้เราเลือกได้ว่าจะรันโค้ดส่วนไหนบ้าง จะรันกี่ครั้ง ทำให้เราเขียนโปรแกรมแก้โจทย์ได้อย่างหลากหลายมากขึ้น 
```python
def main():
	move()
	for i in range(5):
		put_beeper()
		move()
```

```python
def main():
	move()
	put_beeper()
	move()
	put_beeper()
	move()
	put_beeper()
	move()
	put_beeper()
	move()
	put_beeper()
	move()
```


## Abstraction 
ละรายละเอียดปลีกย่อยออกไป

## Control flow - `while` loop


## Control flow - `if else elif`


## Boolean


## การเขียน algorithm