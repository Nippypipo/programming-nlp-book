# เซ็ต (Set)

เซ็ต เป็นโครงสร้างข้อมูลที่เก็บข้อมูลที่ไม่ซ้ำกัน และไม่มีลำดับ ซึ่งล้อกับเซ็ตในคณิตศาสตร์ เซ็ตมีความคล้ายคลึงกับลิสต์ คือ สามารถเก็บข้อมูล และเรียกใช้ข้อมูลที่เก็บเอาไว้ได้ แต่ข้อแตกต่างที่สำคัญ ได้แก่

1. เซ็ตไม่เก็บลำดับของข้อมูล เพราะฉะนั้นเราไม่สามารถใช้ `[index]` ในการเข้าถึงข้อมูลได้ ไม่สามารถใช้ `[]` ในการหั่นเซ็ตได้ ถึงแม้เราสามารถใช้ `for` ในเพื่อเข้าถึงสมาชิกในเซ็ตได้ แต่ว่าลำดับการไล่สมาชิกแต่ละตัวจะไม่ตรงกับลำดับที่เราเพิ่มสมาชิกเข้าไปในเซ็ต

2. เซ็ตไม่เก็บสมาชิกที่ซ้ำกัน ถ้าเราเพิ่มสมาชิกที่มีอยู่แล้วในเซ็ต สมาชิกที่เพิ่มเข้าไปจะไม่ถูกเก็บ และเซ็ตจะไม่แสดง error หรือเกิดข้อผิดพลาดใดๆ ขึ้น

3. การตรวจสอบว่าสมาชิกอยู่ในเซ็ตหรือไม่ ทำได้เร็วกว่าการตรวจสอบในลิสต์ เนื่องจากเซ็ตไม่เก็บลำดับข้อมูล ทำให้อัลกอริทึมในการตรวจสอบการเป็นสมาชิกดำเนินไปได้อย่างรวดเร็ว 

## การสร้างเซ็ต และการหาขนาดของเซ็ต

เซ็ตถูกสร้างขึ้นได้โดยการใช้ `{}` หรือคำสั่ง `set()` ถ้าต้องการสร้างเซ็ตว่าง สามารถใช้ `{}` หรือคำสั่ง `set()` ได้เลย ดังตัวอย่างต่อไปนี้

```python
basket = {}
basket = set()
```

หากต้องการสร้างเซ็ตแบบเป็นค่าคงที่ (literal) กล่าวคือสมาชิกของลิสต์ถูกระบุเอาไว้โดยตรงในโค้ด 
เราสามารถใช้ `{}` ในการสร้างเซ็ต และใส่สมาชิกที่ต้องการเก็บในเซ็ตลงไปใน `{}` ซึ่งสมาชิกแต่ละตัวจะต้องคั่นด้วย `,` และสมาชิกที่ซ้ำกันจะถูกเก็บเพียงตัวเดียว ดังตัวอย่างต่อไปนี้

```python
basket = {'apple', 'orange', 'apple', 'orange', 'banana'}
basket # เก็บแค่ {'orange', 'banana', 'apple'}
```

หากใช้คำสั่ง `set` ในการสร้างเซ็ต จะต้องใส่ลิสต์หรือสตริงที่ต้องการเก็บในเซ็ตลงไปใน `set()` ดังตัวอย่างต่อไปนี้

```python
basket = set(['apple', 'orange', 'apple', 'orange', 'banana'])
basket # เก็บแค่ {'orange', 'banana', 'apple'}
```
เพราะฉะนั้นเราสามารถใช้เซ็ตในการเปลี่ยนสมาชิกในลิสต์ให้เหลือแต่สมาชิกที่ไม่ซ้ำกันได้ โดยการเปลี่ยนลิสต์ให้เป็นเซ็ตด้วยคำสั่ง `set` และนำผลลัพท์ที่ได้เปลี่ยนกลับให้เป็นลิสต์ด้วยคำสั่ง `list` ดังตัวอย่างต่อไปนี้

```python
fruits = ['apple', 'orange', 'apple', 'orange', 'banana']
fruit_set = set(fruits)
fruit_list_no_duplicate = list(fruit_set)
```

วิธีการหาขนาดของเซ็ต (หรือจำนวนสมาชิกของเซ็ต) คล้ายคลึงกับการหาขนาดของลิสต์ และการหาขนาดของดิกชันนารี เราใช้ `len()` ในการหาขนาดของเซ็ตได้ ดังตัวอย่างต่อไปนี้

```python
basket = {'apple', 'orange', 'apple', 'orange', 'banana'}
len(basket) # 3
```

## การสร้างเซ็ตด้วย set comprehension
set comprehension คือ วิธีการสร้างเซ็ตที่ใช้คำสั่งแบบกระชับ และสร้างเซ็ตขึ้นมาโดยใช้เวลาน้อยกว่าการสร้างเซ็ตโดยวิธีอื่น ๆ   set comprehension คล้ายคลึงกับ list comprehension ตรงที่เราเริ่มจากแปลงข้อมูลจากลิสต์ ดิกชันนารี หรือเซ็ตอื่นๆ ให้กลายเป็นเซ็ต (แทนที่จะเป็นลิสต์) 

โครงสร้างของการสร้างเซ็ตด้วย set comprehension คล้ายกับ list comprehension เพียงแต่เราเปลี่ยน `[]` เป็น `{}` แทน ดังนี้
```python
{นิพจน์ (expression) for ไอเท็ม in ลิสต์ เซ็ต หรือดิกชันนารี if เงื่อนไข}
```
- นิพจน์ (expression) คือสูตรหรือคำสั่งที่ใช้แปลงไอเท็มแต่ละไอเท็มในลิสต์ เซ็ต หรือดิกชันนารี ให้กลายเป็นสมาชิกของเซ็ตที่เรากำลังสร้างขึ้น
- เงื่อนไขการเข้าสู่เซ็ต (มีหรือไม่มีก็ได้) เป็นสูตรที่แปลงไอเท็มให้เป็นบูลีน ถ้าบูลีนเป็น `True` ไอเท็มจะถูกเพิ่มเข้าไปในเซ็ตที่กำลังสร้างขึ้น แต่ถ้าบูลีนเป็น `False` ไอเท็มจะไม่ถูกเพิ่มเข้าไปในเซ็ตที่กำลังสร้างขึ้น

สมมติว่าเราต้องการสร้างเซ็ตของชื่อนักเรียนที่ลงท้ายด้วยสระอาจากลิสต์รายชื่อนักเรียน
```python
student_names = ['อาทิตยา', 'วิภา', 'อรรถพล', 'วิภา', 'คริส', 'สุชาดา']
aa_name_set = {name for name in student_names if name.endswith('า')}
```
เราสามารถใช้ set comprehension ในการสร้างเซ็ตของชื่อนักเรียนที่ลงท้ายด้วยสระอาได้ด้วยคำสั่งบรรทัดเดียว โครงสร้างของคำสั่ง set comprehension แบ่งเป็นสามส่วนดังนี้
- expression ไม่มีการเปลี่ยนแปลงชื่อนักเรียน แต่เราใช้ `name` ในการเข้าถึงชื่อนักเรียนแต่ละคน
- ไอเท็มเป็นชื่อที่ได้จากการใช้ `for` ในการวนลูปเพื่อเข้าถึงชื่อนักเรียนทุกคนในลิสต์ `student_names`
- เงื่อนไขการเข้าสู่เซ็ต เราใช้ `name.endswith('า')` ในการตรวจสอบว่าชื่อนักเรียนลงท้ายด้วยสระอาหรือไม่ ถ้าลงท้ายด้วยสระอา ชื่อนักเรียนจะถูกเพิ่มเข้าไปในเซ็ตที่กำลังสร้างขึ้น แต่ถ้าไม่ลงท้ายด้วยสระอา ชื่อนักเรียนจะไม่ถูกเพิ่มเข้าไปในเซ็ตที่กำลังสร้างขึ้น

## การตรวจสอบการเป็นสมาชิกโดยใช้ `in`
เราสามารถตรวจสอบว่าข้อมูลที่ได้มาเป็นสมาชิกของเซ็ตหรือไม่ โดยใช้ `in` ได้ ดังตัวอย่างต่อไปนี้

```python
languages = {'French', 'English', 'German', 'Chinese'}
'English' in languages # True
'Thai' in languages # False
```

เซ็ตสละความสามารถในการเก็บลำดับของข้อมูล เพื่อแลกมากับความเร็วในการหาข้อมูล (lookup) ในเซ็ต อัลกอริทึมหลังบ้านของ operator `in` ของลิสต์จะต้องไล่สมาชิกทีละตัว จนกว่าจะเจอสมาชิกที่ต้องการ หรือจนกว่าจะไล่สมาชิกทุกตัวแล้ว ซึ่งในกรณีที่สมาชิกมีจำนวนมาก ในทางตรงกันข้ามอัลกอริทึมหลังบ้านของ operator `in` ใช้อัลกอริทึมที่เรียกว่าแฮชชิง (hashing) ซึ่งใช้เวลาคงที่ ไม่ขึ้นกับจำนวนของสมาชิกที่อยู่ในเซ็ต  ทำให้เซ็ตเป็นโครงสร้างข้อมูลที่เหมาะสมกับการตรวจสอบการเป็นสมาชิกกว่าลิสต์

## for loop ในเซ็ต
เราสามารถใช้ `for` ในการวนลูปเพื่อเข้าถึงสมาชิกทุกตัวในเซ็ตได้ เหมือนกับการทำ `for` บนลิสต์ แต่เมื่อเซ็ตไม่มีการเก็บลำดับของสมาชิกไว้ การไล่ด้วย `for` จึงไม่ได้ไล่ไปตามลำดับของสมาชิกว่าตัวไหนถูกใส่เข้ามาก่อน ใส่เข้ามาทีหลัง 
```python
languages = {'French', 'English', 'German'}
for language in languages:
    print(language)
```
ผลลัพธ์ที่ print ออกมาคือ
```
German
English
French
```
ถึงแม้ผลลัพธ์ออกมาจะดูเหมือนว่าเซ็ตเก็บข้อมูลโดยเรียงลำดับตามพจนานุกรม แต่ว่าเราไม่สามารถการันตีได้ว่าจะได้ลำดับตามพจนานุกรมเสมอไป เพราะโดยคำนิยามแล้วสมาชิกในเซ็ตไม่มีการจัดลำดับใด ๆ ทั้งสิ้น ไพธอนเวอร์ชันต่อไปอาจจะไม่ได้แสดงผลลัพธ์ออกมาเรียงลำดับตามพจนานุกรมอย่างที่เห็นในเวอร์ชันนี้ (3.11) ก็เป็นได้

## การเพิ่มสมาชิกในเซ็ตด้วย `add()` 
เราสามารถเพิ่มสมาชิกในเซ็ตได้โดยใช้คำสั่ง `add` ซึ่งต่างจากคำสั่ง `append` ของลิสต์ คำว่า append ภาษาอังกฤษแปลว่าเพิ่มไปตรงท้าย แต่คำว่า add แปลว่าเพิ่มเข้าไปโดยไม่ได้คำนึงถึงลำดับของสมาชิก ผู้พัฒนาภาษาไพธอนเลือกใช้คำว่า add เพื่อแสดงให้เห็นว่าเซ็ตไม่เก็บลำดับของสมาชิก 

### ตัวอย่าง
สมมติว่าเราทำโจทย์เดียวกับตัวอย่างที่ผ่านมา เราต้องการสร้างเซ็ตของชื่อนักเรียนที่ลงท้ายด้วยสระอาจากลิสต์รายชื่อนักเรียน เราสามารถใช้คำสั่ง `add` เพื่อเพิ่มสมาชิกที่ต้องการเข้าไปทีละตัว แทนที่การใช้ set comprehension ได้ดังนี้

```python 
student_names = ['อาทิตยา', 'วิภา', 'อรรถพล', 'วิภา', 'คริส', 'สุชาดา']
aa_name_set = {} # จะใช้ aa_name_set = set() แทนก็ได้
for name in student_names:
    if name.endswith('า'):
        aa_name_set.add(name)
```

## เอาสมาชิกออกจากเซ็ตด้วย `remove()`
คำสั่งนี้อาจจะเป็นคำสั่งที่ใช้ไม่ได้บ่อยนัก แต่เราควรรู้ไว้เพื่อความสมบูรณ์ของเนื้อหา คำสั่ง `remove` ใช้ในการลบสมาชิกออกจากเซ็ต โดยเราต้องระบุสมาชิกที่ต้องการลบออกไป ดังตัวอย่างต่อไปนี้

### ตัวอย่าง
สมมติว่ามีคำตอบในแบบสอบที่มีตัวเลือก 5 ตัวเลือก คือ Strongly disagree, Disagree, Neutral, Agree, Strongly agree และเราต้องการลบตัวเลือก Strongly disagree และ Strongly agree ออกจากเซ็ตของตัวเลือกที่เป็นไปได้

```python
possible_responses = {'Strongly disagree', 'Disagree', 'Neutral', 'Agree', 'Strongly agree'}
possible_responses.remove('Strongly disagree')
possible_responses.remove('Strongly agree')
```

## Set operation: intersection union และการลบกันของเซ็ต
เซ็ตในภาษาไพธอนรองรับ set operation ทุกตัว สมมติว่าเรามีเซ็ต A เก็บอยู่ในตัวแปร `setA` และเซ็ต B เก็บอยู่ในตัวแปร `setB`

- intersection (A ∩ B) คือ การสร้างเซ็ตที่ประกอบด้วยสมาชิกที่อยู่ทั้งในเซ็ต A และเซ็ต B ภาษาไพธอนใช้คำสั่ง `setA.intersection(setB)`
- union (A ∪ B) คือ การสร้างเซ็ตที่ประกอบด้วยสมาชิกที่อยู่ในเซ็ต A หรือเซ็ต B อย่างน้อยหนึ่งเซ็ต ภาษาไพธอนใช้คำสั่ง `setA.union(setB)`
- การลบกันของเซ็ต (A - B) คือ การสร้างเซ็ตที่ประกอบด้วยสมาชิกที่อยู่ในเซ็ต A แต่ไม่อยู่ในเซ็ต B ภาษาไพธอนใช้คำสั่ง `setA - setB` หรือ `setA.difference(setB)`

เซ็ตในโลกของการประมวลผลภาษาธรรมชาติมักจะใช้ในการเก็บรายการคำศัพท์ (vocabulary หรือ vocab) เช่น คำศัพท์ที่ปรากฏทั้งหมดในข้อสอบชุดหนึ่ง คำศัพท์ที่เห็นทั้งหมดในคลังข้อมูล (corpus ชุดข้อมูลที่รวบรวมข้อมูลภาษาเอาไว้จำนวนมาก) คำศัพท์ที่แบบจำลองเข้าใจความหมายอยู่แล้ว เซ็ตเหมาะแก่การเก็บ vocabulary เพราะ vocabulary ประกอบด้วยคำศัพท์พบเห็นอย่างน้อยหนึ่งครั้ง โดยไม่คำนึงว่าเกิดขึ้นซ้ำหรือไม่ และไม่คำนึงถึงลำดับการเกิดของคำศัพท์ นอกจากนั้นแล้วเซ็ตในภาษาไพธอนยังรองรับการใช้ set operation ได้อย่างสะดวกสบายอีกด้วย 

ตัวอย่างข้างล่างนี้สมมติว่ามี vocabulary ที่ใหญ่มากซึ่งได้มาจากแบบจำลองภาษาขนาดใหญ่ ครอบคลุมหลายภาษาเก็บอยู่ในตัวแปร `multilingual_vocab` และมี vocabulary ที่มาจากแบบจำลองของภาษาไทยภาษาเดียว เก็บอยู่ในตัวแปร `thai_vocab` 

### ตัวอย่าง: intersection
สมมติว่าเราต้องการหาว่าคำศัพท์คำใดบ้างที่ปรากฏในทั้งสองเซ็ต คือ `multilingual_vocab` และ `thai_vocab` สามารถใช้คำสั่ง `intersection` ในการหาคำศัพท์ที่ปรากฏในทั้งสองตัวแปรได้ดังนี้

```python
multilingual_vocab = {'hello', 'สวัสดี', '你好', 'สวัสดี', 'สวัสดี', 'สวัสดี'}
thai_vocab = {'สวัสดี', 'ขอบคุณ'}
multilingual_vocab.intersection(thai_vocab) # {'สวัสดี'}
```
หลังจากรันโค้ดแล้วลอง `print` ค่าที่ปรากฏอยู่ในตัวแปรจะได้ผลดังนี้
```python
print(multilingual_vocab)
```
output ที่ปรากฏบนหน้าจอ คือ
``` {'你好', 'สวัสดี', 'hello'}```

```python
print(thai_vocab)
```
output ที่ปรากฏบนหน้าจอ คือ
``` {'ขอบคุณ', 'สวัสดี'}```
คำสั่ง `intersection` คืนค่าเป็นเซ็ตใหม่ขึ้นมาต่างหาก แยกต่างหากจาก `multilingual_vocab` และ `thai_vocab` ที่เราใช้ในการเรียกคำสั่ง หลังจากเรียกคำสั่ง set operation แล้ว สมาชิกของ `multilingual_vocab` และ `thai_vocab` จะไม่เปลี่ยนแปลง

เพราะฉะนั้นที่ถูกต้องคือ ต้องเก็บค่าที่คืนมาจากคำสั่งไว้ในตัวแปรใหม่ 
```python
multilingual_vocab = {'hello', 'สวัสดี', '你好', 'สวัสดี', 'สวัสดี', 'สวัสดี'}
thai_vocab = {'สวัสดี', 'ขอบคุณ'}
overlapping_vocab = multilingual_vocab.intersection(thai_vocab) # {'สวัสดี'}
```
หากเราต้องการทราบจำนวนสมาชิกของแต่ละเซ็ต สามารถใช้ `len()` ในการหาได้ ดังตัวอย่างต่อไปนี้
```python
print(len(multilingual_vocab)) 
print(len(thai_vocab)) 
print(len(overlapping_vocab)) 
```
output ที่จะปรากฏบนหน้าจอ คือ 
```python
4
2
1
```

### ตัวอย่าง: union
สมมติว่าเราต้องการขยายความสามารถของโมเดลหลากภาษา โดยการขยาย vocabulary ของโมเดลหลากภาษาให้มีคำศัพท์ที่มาจากแบบจำลองภาษาไทยด้วย สามารถใช้คำสั่ง `union` ในการขยาย vocabulary ของโมเดลหลากภาษาได้ดังนี้

```python
multilingual_vocab = {'hello', 'สวัสดี', '你好', 'สวัสดี', 'สวัสดี', 'สวัสดี'}
thai_vocab = {'สวัสดี', 'ขอบคุณ'}
larger_vocab = multilingual_vocab.union(thai_vocab) 
print(larger_vocab)
```
หลังจากรันโค้ดแล้วลอง `print` ค่าที่ปรากฏอยู่ในตัวแปรจะได้ผลดังนี้
```python
{'สวัสดี', 'hello', 'ขอบคุณ', '你好'}
```
คำสั่ง `union` คืนค่าเป็นเซ็ตใหม่ขึ้นมาต่างหาก แยกต่างหากจาก `multilingual_vocab` และ `thai_vocab` ที่เราใช้ในการเรียกคำสั่ง เช่นเดียวกับการใช้คำสั่ง `intersection`

ข้อสังเกตอีกอย่างหนึ่งคือ สมาชิกของเซ็ตที่คืนมาจากการใช้คำสั่ง `union` จะไม่เรียงลำดับตามพจนานุกรม หรือเรียงลำดับใด ๆ เลย แต่เราสามารถใช้ `sorted()` ในการเรียงลำดับสมาชิกของเซ็ตได้ ดังตัวอย่างต่อไปนี้

```python
multilingual_vocab = {'hello', 'สวัสดี', '你好', 'สวัสดี', 'สวัสดี', 'สวัสดี'}
thai_vocab = {'สวัสดี', 'ขอบคุณ'}
larger_vocab = multilingual_vocab.union(thai_vocab)
print(sorted(larger_vocab))
```
output ที่จะปรากฏบนหน้าจอ คือ 
```python
['hello', 'ขอบคุณ', 'สวัสดี', '你好']
```
สังเกตว่าผลที่ได้จะออกมาเป็นลิสต์ ซึ่งเป็นพฤติกรรมที่สมเหตุสมผลของคำสั่ง `sorted` เนื่องจากเราจำเป็นต้องใช้โครงสร้างข้อมูลที่มีการเก็บลำดับของสมาชิกแต่ละตัว 

### ตัวอย่าง: การลบกันของเซ็ต
สมมติเราต้องการทราบว่า `thai_vocab` มีคำศัพท์ภาษาไทยมากกว่า `multilingual_vocab` กี่คำ สามารถใช้คำสั่ง `difference` ในการหาคำศัพท์ที่มีใน `thai_vocab` แต่ไม่มีใน `multilingual_vocab` ได้ดังนี้

```python
multilingual_vocab = {'hello', 'สวัสดี', '你好', 'สวัสดี', 'สวัสดี', 'สวัสดี'}
thai_vocab = {'สวัสดี', 'ขอบคุณ'}
thai_only_vocab = thai_vocab.difference(multilingual_vocab)
print(thai_only_vocab)
```
หลังจากรันโค้ดแล้วลอง `print` ค่าที่ปรากฏอยู่ในตัวแปรจะได้ผลดังนี้
```python
{'ขอบคุณ'}
```
คำสั่ง `difference` คืนค่าเป็นเซ็ตใหม่ขึ้นมาต่างหาก แยกต่างหากจาก `multilingual_vocab` และ `thai_vocab` ที่เราใช้ในการเรียกคำสั่ง เช่นเดียวกับการใช้คำสั่ง `intersection` และ `union`

## สรุป
เซ็ตในภาษาไพธอนเป็นโครงสร้างข้อมูลที่เหมาะสมกับการเก็บข้อมูลที่ไม่มีการจัดลำดับ และไม่มีการเก็บข้อมูลที่ซ้ำกัน โดยเซ็ตในภาษาไพธอนมีความสามารถในการใช้ set operation ได้ทั้งหมด 3 ตัว คือ intersection union และการลบกันของเซ็ต ในการประมวลผลภาษาธรรมชาติเซ็ตมักถูกใช้ในการเก็บรายการคำศัพท์ หรือเรียกว่า vocabulary 

คำสั่งของเซ็ตในภาษาไพธอน สรุปเป็นตารางได้ดังนี้
| operation | สัญลักษณ์ทางคณิตศาสตร์ | คำสั่งในไพธอน | 
| --- | --- | --- | 
| intersection | A ∩ B | `setA.intersection(setB)` | 
| union | A ∪ B | `setA.union(setB)` | 
| difference | A - B | `setA - setB` หรือ `setA.difference(setB)` | 

ทั้งสามคำสั่งจะคืนค่าออกมาเป็นเซ็ตใหม่แยกต่างหากจาก `setA` และ `setB` ที่เราใช้ในการเรียกคำสั่ง หลังจากเรียกคำสั่ง set operation แล้ว สมาชิกของ `setA` และ `setB` จะไม่เปลี่ยนแปลง



