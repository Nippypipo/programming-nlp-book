## การเขียนโปรแกรมเชิงอ็อบเจกต์ (Object-Oriented Programming)

สมมติว่าเราต้องการเก็บข้อมูลของคำแต่ละคำที่อยู่ในย่อหน้าย่อหน้าหนึ่ง  โครงสร้างข้อมูลที่เหมาะกับข้อมูลประเภทนี้ คือ ลิสต์ที่เก็บสตริง เช่น
```python
paragraph = ['Apple', 'Inc.' 'is' 'an' 'American' 'multinational' 'technology' 'firm'  'headquartered', 'in' 'Cupertino', 'California' '.']
```
แต่สมมติอีกว่าเราต้องการเก็บข้อมูลของแต่ละคำอย่างละเอียดขึ้น เช่น ประเภทของคำ (part-of-speech tag) ประเภทของชื่อเฉพาะ (named entity tag) คำนี้เป็นภาษาอะไร คำนี้เป็นคำที่ขึ้นต้นประโยคหรือไม่ คำนี้มีรูปก่อนการผันรูปเป็นอะไร (lemma)   โครงสร้างข้อมูลที่เหมาะกับข้อมูลประเภทนี้ คือ ลิสต์ของดิกชันนารี เช่น
```python
paragraph = [
    {'word': 'Apple', 'pos': 'NNP', 'ner': 'ORG', 'lang': 'en', 'is_first': True, 'lemma': 'apple'},
    {'word': 'Inc.', 'pos': 'NNP', 'ner': 'ORG', 'lang': 'en', 'is_first': False, 'lemma': 'inc.'},
    {'word': 'is', 'pos': 'VBZ', 'ner': 'O', 'lang': 'en', 'is_first': False, 'lemma': 'be'},
    {'word': 'an', 'pos': 'DT', 'ner': 'O', 'lang': 'en', 'is_first': False, 'lemma': 'an'},
    {'word': 'American', 'pos': 'JJ', 'ner': 'MISC', 'lang': 'en', 'is_first': False, 'lemma': 'american'},
    {'word': 'multinational', 'pos': 'JJ', 'ner': 'O', 'lang': 'en', 'is_first': False, 'lemma': 'multinational'},
    {'word': 'technology', 'pos': 'NN', 'ner': 'O', 'lang': 'en', 'is_first': False, 'lemma': 'technology'},
    {'word': 'firm', 'pos': 'NN', 'ner': 'O', 'lang': 'en', 'is_first': False, 'lemma': 'firm'},
    {'word': 'headquartered', 'pos': 'VBN', 'ner': 'O', 'lang': 'en', 'is_first': False, 'lemma': 'headquarter'},
    {'word': 'in', 'pos': 'IN', 'ner': 'O', 'lang': 'en', 'is_first': False, 'lemma': 'in'},
    {'word': 'Cupertino', 'pos': 'NNP', 'ner': 'LOC', 'lang': 'en', 'is_first': False, 'lemma': 'cupertino'},
    {'word': 'California', 'pos': 'NNP', 'ner': 'LOC', 'lang': 'en', 'is_first': False, 'lemma': 'california'},
    {'word': '.', 'pos': '.', 'ner': 'O', 'lang': 'en', 'is_first': False, 'lemma': '.'}
]
```
อย่างแรกที่เราสังเกตได้คือ ดิกชันนารีที่เราใช้มีฟิลด์ถึง 6 ฟิลด์ การจะเขียนโปรแกรมขึ้นมาเพื่อประมวลผลวิเคราะห์ข้อมูลประเภทนี้ เราจะต้องระวังว่าดิกชันนารีแต่ละอันที่เก็บข้อมูลของคำจะต้องมีฟิลด์เท่ากันหมด และผู้ที่เขียนฟังก์ชันเพื่อประมวลผลดิกชันนารีจะต้องทราบด้วยว่าฟิลด์เหล่านี้มีอะไรบ้าง เก็บอะไรไว้บ้าง ถ้าหากมีการเปลี่ยนแปลงชื่อฟิลด์ หรือเพิ่มฟิลด์ใหม่ ฟังก์ชันที่เขียนขึ้นมาเพื่อประมวลผลดิกชันนารีจะต้องถูกแก้ไขใหม่ทั้งหมด ซึ่งอาจจะทำให้เกิดข้อผิดพลาดได้ เพราะว่าโค้ดที่ใช้ในการสร้างดิกชันนารีขึ้นมา กับโค้ดที่ใช้ในการประมวลผลอาจจะอยู่คนละที่ คนละไฟล์กัน ทำให้โค้ดที่เขียนขึ้นมานั้นยากต่อการบำรุงรักษา และยากต่อการเปลี่ยนแปลง 

## คลาส (class) และอ็อบเจกต์ (object)
การเขียนโปรแกรมเชิงอ็อบเจกต์ (Object-Oriented Programming: OOP) คือหลักการที่เราจะใช้ในการออกแบบโครงสร้างข้อมูลเพื่อให้สะดวกกับกรณีการใช้งานดังตัวอย่างข้างต้น หลักการของ OOP คือการออกแบบโครงสร้างข้อมูลขี้นมาเป็นพิเศษ เจาะจงกับข้อมูลที่เราต้องการจะเก็บ โครงสร้างข้อมูลนี้เรียกว่าคลาส (class) 

คลาสในภาษาไพธอน[^pythonoop] ประกอบลักษณะพิเศษหลัก ๆ 3 อย่าง คือ

1. ลักษณะประจำ (attribute) 
2. เมท็อด (method) ซึ่งเป็นโค้ดที่ใช้ประมวลผลลักษณะประจำคลาส 
3. สิ่งสืบทอด (inheritance) ซึ่งใช้ดึงเอาเมท็อดจากคลาสอื่นมาใช้ 

## ลักษณะประจำ (attribute)
ลักษณะประจำ เป็นตัวแปรที่เก็บซ้อนอยู่ในคลาส ใช้เก็บข้อมูลคล้ายคลึงกับตัวแปร เพื่อให้เห็นภาพมากขึ้น เราจะลองเขียนคลาสเพื่อใช้เก็บข้อมูลเกี่ยวกับคำในประโยคแทนที่ดิกชันนารี เราขอเรียกว่าโทเค็น (token) แทนที่คำว่า *คำ* [^token] โทเค็น หมายถึง หน่วยหนึ่งหน่วยที่ผู้วิเคราะห์ใช้เป็นหน่วยที่เล็กที่สุดในการประมวลผล ตัวอย่างโค้ดในการกำหนดคลาสมีดังนี้

[^pythonoop]: ไพธอนไม่ได้สนับสนุนลักษณะเด่น ๆ อื่น ๆ ของการเขียนโปรแกรมเชิงอ็อบเจกต์ เช่น การกำหนดสาระสำคัญ (abstraction) การห่อหุ้ม (encapsulation) ภาวะพหุสัณฐาน
(polymorphism)  ผู้เขียนจึงขอเน้นเฉพาะลักษณะที่ภาษาไพธอนสนับสนุนเท่านั้น

[^token]: เนื่องจากคำในความหมายที่อ้างอิงตามมโนทัศน์ทางภาษาศาสตร์มีคำนิยามเฉพาะซึ่งไม่เหมือนกับโทเค็น 

```python
class Token:
    word = ''
    pos = ''
    ner = ''
    lang = ''
    is_first = False
    lemma = '' 
```
บรรทัดแรก คือ การตั้งชื่อคลาส โดยการใช้คีย์เวิร์ด `class` ตามด้วยชื่อคลาส ชื่อคลาสมักจะใช้การสะกดแบบหลังอูฐ (camel case) ถ้าหากชื่อคลาสประกอบด้วยคำหลายคำ ให้ตัวอักษรแรกของแต่ละคำเป็นตัวใหญ่เช่น (`LanguageModel`, `AutoTokenizer`, `DefaultModelConfiguration`) จากนั้นให้ปิดด้วย `:`

บรรทัดต่อมา จะต้องเริ่มด้วยการเคาะย่อหน้าเพื่อบ่งบอกว่าโค้ดบล็อกที่อยู่ในย่อหน้านั้นเป็นของการกำหนดคลาส และจากนั้นก็เป็นการกำหนดลักษณะประจำคลาส (class attribute)ซึ่งจะเป็นการกำหนดตัวแปรที่คลาสนี้จำเป็นต้องมี  ในตัวอย่างนี้เรากำหนดลักษณะประจำของคลาส `Token` มีลักษณะประจำทั้งหมด 6 อย่าง คือ `word`, `pos`, `ner`, `lang`, `is_first`, `lemma` โดยเรากำหนดค่าเริ่มต้นให้กับลักษณะประจำทั้งหมด โดยใช้เครื่องหมาย `=` คล้ายคลึงกับการกำหนดค่าตัวแปร 

คลาส เป็นเพียงแค่ต้นแบบ หรือแบบแปลนให้ทราบว่าหนึ่งโทเคนนั้นจะต้องประกอบไปด้วยตัวแปรย่อย ๆ ซึ่งก็คือลักษณะประจำคลาส เมื่อเราต้องการนำคลาสนี้ไปใช้เก็บข้อมูล จะต้องมีการสร้างอ็อบเจกต์ (object) ของคลาสนี้ กระบวนการนี้เรียกว่า การสร้างกรณีตัวอย่าง (instantiation) ในภาษาไพธอนมีวิธีการสร้างอ็อบเจกต์โดยการใช้ชื่อคลาสตามด้วย `()` เช่น

```python
first_word = Token()
second_word = Token()
```
เราได้สร้างอ็อบเจกต์ของคลาสเก็บใส่ตัวแปร `first_word` และ `second_word` ในการกระบวนการนี้เราได้สร้างตัวแปรย่อย 6 ตัวเก็บไว้ใน `first_word` และตัวแปรย่อยอีก 6 ตัวเก็บไว้ใน `second_word` เป็นตัวแปรสองชุดแยกจากกันโดยสิ้นเชิง

ถ้าหากเราต้องการเข้าถึงหรือกำหนดค่าใหม่ให้ตัวแปรที่อยู่ในอ็อบเจกต์ ให้ใช้ `.`ตามด้วยชื่อของตัวแปร
```python 
first_word.word = 'Apple'
first_word.pos = 'NNP'
first_word.ner = 'ORG'
first_word.lang = 'en'
first_word.is_first = True
first_word.lemma = 'apple'

second_word.word = 'Inc.'
second_word.pos = 'NNP'
second_word.ner = 'ORG'
second_word.lang = 'en'
second_word.is_first = False
second_word.lemma = 'inc.'
```
จะเห็นได้ว่าการใช้คลาสที่สร้างขึ้นมาพิเศษในการเก็บข้อมูลแทนที่ดิกชันนารีมีข้อได้เปรียบหลายอย่าง อย่างแรกคือรับประกันได้ว่า `first_word` และ `second_word` มีจำนวนข้อมูลเท่ากันเพราะว่าเป็นอ็อบเจกต์ที่สร้างมาจากคลาสเดียวกัน และชื่อของตัวแปรย่อยที่อยู่ในอ็อบเจกต์เหล่านี้ก็ต้องเหมือนกัน และตัวแปรเหล่านั้นควรจะเก็บข้อมูลอย่างเดียวกันอยู่ อย่างที่สองคือการใช้ `.` เพื่อเข้าถึงข้อมูลที่อยู่ในอ็อบเจกต์สะดวกกว่าการใช้ `[]` เพื่อเข้าถึงข้อมูลที่อยู่ในดิกชันนารี เช่น
```python
first_word['word']
first_word.word
```
อย่างที่สามคือ หากเราใช้ IDE ที่ดี ๆ อย่าง PyCharm หรือ Visual Studio Code หรือปัญญาประดิษฐ์ที่ช่วยในการเขียนโค้ด เช่น GitHub Copilot เครื่องมือเหล่านี้จะช่วยเติมโค้ดให้สมบูรณ์โดยอัตโนมัติได้ เพราะว่าการกำหนดคลาสเป็นส่วนหนึ่งของโค้ดที่ IDE ได้ทำความเข้าใจแล้ว เช่น หากเราพิมพ์ `first_word.w` และ IDE สแกนและทำความเข้าใจเรียบร้อยแล้วว่า `first_word` มาจากคลาส `Token` ซึ่งมีลักษณะประจำชื่อว่า `word` ซึ่งเป็นตัวแแปรเดียวที่ขึ้นต้นด้วย w IDE จึงมีความสามารถที่จะเติมโค้ดให้เราเป็น `first_word.word` โดยอัตโนมัติ 

นอกจากนั้นแล้วหากเราห่างจากโค้ดก้อนนี้ไปนาน ๆ แล้วต้องกลับมาเขียนโค้ดเพิ่ม หรือต้องร่วมงานกับคนอื่นที่ต้องใช้โค้ดร่วมกับเรา เราก็สามารถอ้างอิงไปยังโค้ดที่กำหนดคลาส เพื่อทำความเข้าใจว่าคลาสที่เห็นอยู่เก็บข้อมูลอะไรอยู่บ้าง ซึ่งต่างจากดิกชันนารีที่ไม่มีโค้ดที่กำหนดคีย์ทั้งหมดของดิกชันนารีอย่างเป็นหลักเป็นแหล่งใช้อ้างอิงได้ 

## เมท็อด (method)
ก่อนถึงบทนี้เราได้มีการใช้เมท็อดโดยการใช้ `.` มาหลายครั้งแล้ว เพราะว่าทั้งสตริง ทั้งลิสต์ ทั้งดิกชันนารีต่างก็เป็นอ็อบเจกต์ทั้งหมด และเมท็อดเป็นโค้ดที่ใช้ประมวลผลข้อมูลที่อยู่ในอ็อบเจกต์ เพราะฉะนั้นเราจึงถือได้ว่า เมท็อดเป็นฟังก์ชันที่เป็นลักษณะเฉพาะเจาะจงของคลาส เช่น คลาสลิสต์มีเมท็อดที่ชื่อว่า `append` และ `pop` ซึ่งเป็นเมท็อดที่ใช้ในการปฏิสัมพันธ์กับข้อมูลที่อยู่ในอ็อบเจกต์ที่เป็นลิสต์ 

### เมท็อดของคลาส

ในการกำหนดคลาส เราสามารถกำหนดเมท็อดให้คลาสได้ด้วย โดยการใช้คีย์เวิร์ด `def` ตามด้วยชื่อเมท็อด `()` และ `:` และอาร์กิวเมนต์แรกจะต้องเป็นคีย์เวิร์ด `self` ตัวอย่างเช่น
```python 
class Token:
    word = ''
    pos = ''
    ner = ''
    lang = ''
    is_first = False
    lemma = '' 

    def to_plural_form(self):
        if self.pos[0] == 'N':
            self.word = self.word + 's'
```
`self` คืออะไร และทำไมต้องใช้ `self` ในการกำหนดเมท็อด ในภาษาไพธอน การใช้ `self` ในการกำหนดเมท็อดเป็นการบอกว่าเมท็อดนี้เป็นเมท็อดของคลาส และเมท็อดนี้จะใช้ตัวแปร `self` เข้าถึงข้อมูลที่อยู่ในอ็อบเจกต์ซึ่งก็คือตัวแปร (ลักษณะประจำ) ทั้งหมด ในตัวอย่างนี้เมท็อด `to_plural_form` ใช้ `self` เข้าถึงตัวแปร `pos` และ `word` และเปลี่ยนค่าของ `word` ให้เป็นรูปพหุสัณฐานของ `word` ถ้าหาก `pos` ของคำนั้นเป็น N ซึ่งหมายถึงคำนั้นเป็นนาม และเมท็อดนี้จะเปลี่ยนค่าของ `word` ในอ็อบเจกต์ที่เรียกเมท็อดนี้ ซึ่งเป็นการเปลี่ยนค่าของ `word` ในอ็อบเจกต์ที่เรียกเมท็อดนี้เท่านั้น ไม่ได้เปลี่ยนค่าของ `word` ในอ็อบเจกต์อื่น ๆ ที่เก็บอยู่ในตัวแปรอื่น ๆ 

ตัวอย่างการใช้เมท็อด `to_plural_form` ในการเปลี่ยนคำว่า `firm` ให้เป็น `firms` แสดงในโค้ดด้านล่าง
```python
word = Token()
word.word = 'firm'
word.pos = 'NN'
word.ner = 'O'
word.lang = 'en'
word.is_first = False
word.lemma = 'firm'

word.to_plural_form()
print(word.word) # firms
```
สังเกตว่าเวลาเรียกใช้เมท็อด `.to_plural_form` เราไม่ต้องใส่ `self` ลงไป เวลาเราเรียกใช้เมท็อด ไพธอนทราบเองโดยอัตโนมัติว่าเป็นการใช้เมท็อดของอ็อบเจกต์ที่อยู่ใน `word`  และจะส่งอ็อบเจกต์ที่เรียกเมท็อดนี้เข้าไปในอาร์กิวเมนต์แรกของเมท็อด ซึ่งเป็นเหตุผลที่ทำให้เราไม่ต้องใส่ `self` ลงไปในอาร์กิวเมนต์ของเมท็อดอีก 


