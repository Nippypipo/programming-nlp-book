# เคาน์เตอร์ (counter)
เคาน์เตอร์ เป็น*ซับคลาส (subclass)* ของดิกชันนารี ซึ่งแปลว่าเคานเตอร์สามารถทำได้เกือบทุกอย่างที่ดิกชันนารีสามารถทำได้ และยังมี method อืิ่น ๆ เพิ่มเติม 

เคาน์เตอร์เป็นดิกชันนารีที่ key เป็นอะไรก็ได้ แต่ว่า value จะต้องเป็นตัวเลข เท่านั้น จุดประสงค์หลักของการใช้โครงสร้างข้อมูลชนิดนี้คือเพื่อเก็บจำนวนครั้งที่พบ key แต่ละอัน 

เคาน์เตอร์ไม่ใช่ *บิวท์อินคลาส (built-in class)* ก่อนจะใช้จะต้อง `import` เข้ามาก่อนที่จะเรียกใช้ เคาน์เตอร์เป็นคลาสที่เป็นส่วนหนึ่งของโมดูล `collections` 

## การสร้างเคาน์เตอร์ว่าง ๆ
ใช้คำสั่ง `Counter()` ในการสร้างเคาน์เตอร์ซึ่งเป็นคำสั่งที่ต้อง `import` เข้ามาก่อน
```python
from collections import Counter
word_count = Counter()
```
## การสร้างเคาน์เตอร์จากดิกชันนารี
เราสร้างแปลงดิกชันนารีที่ value เป็นตัวเลขมาเป็นเคาน์เตอร์ได้ดังนี้
```python
word_count = Counter({'b':1, 'a':3, 'c':1})
```

## การสร้างเคาน์เตอร์จากลิสต์
การสร้างเคาน์เตอร์ คือ การใช้เคาน์เตอร์สามารถนับค่าต่าง ๆ ที่เก็บอยู่ในลิสต์ และจัดเก็บให้ค่าทั้งหมดเป็น key และจำนวนครั้งที่พบให้เก็บเป็น value 
```python
letter_list = ['a', 'b', 'c', 'a','b', 'a']
letter_count = Counter(letter_list)
letter_count['a'] #--> 3
letter_count['b'] #--> 2
letter_count['c'] #--> 1
```

## key ที่ไม่ได้อยู่ในเคาน์เตอร์ value จะเป็น 0
เมื่อเวลาเราเปิดหาค่า key ที่ไม่ได้มีอยู่ในเคาน์เตอร์ค่าที่ได้คืนมาจะเป็น 0 เสมอ ซึ่งต่างจากดิกชันนารีที่จะโยน `KeyError` กลับมา
```python
letter_count['d'] #--> 0
```
ฟีเจอร์นี้ทำให้เราใช้เคาน์เตอร์ได้สะดวกมากขึ้น เมื่อเราต้องการถามว่าค่าอะไรเจอกี่ครั้งบ้าง ถ้าค่าที่ไม่เจอเลยค่าที่ได้กลับคืนมาก็ควรจะเป็น 0 นอกจากนั้นแล้วเราสามารถอัพเดทเคาน์เตอร์ได้โดยไม่จำเป็นต้องตรวจสอบก่อนว่า key นั้นเคยมีอยู่ในเคาน์เตอร์แล้วหรือยัง เช่น สมมติว่าเราต้องการนับแค่คำที่ไม่มีตัวเลขปะปนอยู่เลยที่จัดเก็บอยู่ในลิสต์ `word_list`
```python
word_counter = Counter()
for word in word_list:
    if word.isalpha():
        word_counter[word] = word_counter[word] + 1
```
`word_counter[word]` ค่าเป็น 0 ถ้าเราไม่เคยเห็นคำนั้นมาก่อนซึ่งทำให้ expression ทางขวามือของเครื่องหมายเท่ากับเป็น `0 + 1` ซ่ึงเป็นผลที่เราต้องการ 
ถ้าหากเราจะใช้ดิกชันนารีก็สามารถทำได้ 
```python
word_counter = {}
for word in word_list:
    if word.isalpha():
        if word not in word_counter:
            word_counter[word] = 0
        word_counter[word] = word_counter[word] + 1
```
แต่เราต้องตรวจสอบว่า key อยู่ในดิกอยู่แล้วหรือไม่ ถ้าไม่ได้อยู่ต้องทำการตั้งคู่ key-value ใหม่โดยตั้งให้ค่า value เป็น 0 เตรียมเอาไว้ก่อน เพื่อป้องกัน `KeyError` 

## หาค่า key ที่คู่กับ value ที่สูงที่สุด: `.most_common()`
เคาน์เตอร์มี method ที่ไว้สำหรับ key ที่พบบ่อยที่สุด 
```python
letter_list = ['a', 'b', 'c', 'a','b', 'a']
letter_count = Counter(letter_list)
letter_count.most_common() #--> [('a', 3), ('b', 2), ('c', 1)]
letter_count.most_common(1) #--> [('a', 3)]
```
method นี้มี optional parameter ที่เราจะระบุหรือไม่ระบุก็ได้ว่าจะ return ผลกี่อันดับแรก ถ้าไม่ระบุจะให้ผลอย่างมาก 20 อันดับแรก สิ่งที่ method return มาให้คือลิสต์ของทูเปิล ทูเปิลที่ได้มาเป็นคู่ของ key-value เรียงลำดับตาม value 