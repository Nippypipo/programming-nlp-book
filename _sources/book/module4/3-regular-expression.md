# Regular expression
*Under construction*

Regular expression (regex อ่านว่า /regeks/) เป็นวิธีการเขียนจับแพทเทิร์น เพื่อที่จะได้ดึงข้อมูลที่อยากได้ออกมาโดยสะดวก เช่น 
- `[a-z.]+@[a-z]+\.com` เป็น regex สำหรับแพทเทิร์นของ email address ที่ลงท้ายด้วย .com
- `\d\d\d-\d\d\d-\d\d\d\d` เป็น regex  สำหรับแพทเทิร์นของหมายถึงเลขโทรศัพท์ เช่น 123-123-1234

Regex มีความสำคัญมากๆ ในการทำงานเกี่ยวกับการประมวลผลภาษาธรรมชาติ  เพราะทำให้เราสามารถดึงข้อมูลที่มีแพทเทิร์นเด่นชัดในภาษา (เช่น อีเมล์ เบอร์โทรศัพท์ ชื่อ ตัวย่อ) ออกมาจากข้อความที่เราต้องการประมวลผลได้สะดวก  

## ส่วนประกอบของ regular expression

การเขียน regex ประกอบด้วย 4 ส่วนใหญ่ๆ

###	ตัวอักษรปกติ 
ตัวอักษรบางตัวทับกับสัญลักษณ์อื่น ๆ ที่มีความหมายพิเศษใน regular expression ได้แก่ `. + * ? ^ $ ( ) [ ] { } |` เลยต้องทำการหนี (escape) โดยเพิ่ม \ เข้าไปข้างหน้า

### สัญลักษณ์แทนตัวอักษรหรือกลุ่มของตัวอักษร

| สัญลักษณ์ | แทนตัวอะไรบ้าง                        |
|--------|-------------------------------------|
| ^      | หน้าสุดของ string                     |
| $      | ท้ายสุดของ string                     |
| .      | ตัวอะไรก็ได้                           |
| \w     | (**w**ord) a-z A-Z 0-9 และ _  |
| \W     | อะไรก็ได้ที่ไม่ใช่ \w                     |
| \d     | (**d**igit) ตัวเลข 0-9              |
| \D     | อะไรก็ได้ที่ไม่ใช่ \d                     |
| \s     | \space ช่องว่างรวมถึง \t\n\r   |
| \S     | อะไรก็ได้ที่ไม่ใช่ \s                     |
| \b     | ตัวแบ่งคำ (แบบภาษาอังกฤษ)              |

### การจัดเซ็ตของตัวอักษร

| สัญลักษณ์     | แทนตัวอะไรบ้าง       | ตัวอย่าง                         |
|------------|--------------------|--------------------------------|
| `[abc]`      | ตัวอักษรตัวหนึ่งใน set  | `b[aei]d` match bad bed bid      |
| `[a-z]`      | ไล่ตัวอักษรทำเป็น set  | `[b-d]ad` match bad cad dad      |
| `[^abc]`     | อะไรก็ได้ที่ไม่อยู่ใน set | `b[^aei]d` match bbd bcd bdd  |
| `aaa\|bb\|c` | aaa หรือ bb หรือ c   | `bea\|ook` match bea ook         |

### ตัวบอกปริมาณ (quantifier)

เราสามารถระบุปริมาณของตัวอักษรหรือกลุ่มของตัวอักษรโดยการใช้ตัวอักษรร่วมกับ quantifier

| quantifier | แปลว่า                            |
|------------|----------------------------------|
| +          | อย่างน้อยหนึ่งตัว (1 or more)         |
| *          | กี่ตัวก็ได้ หรือไม่มีสักตัวก็ได้ (0 or more) |
| ?          | 1 ตัว หรือไม่มีก็ได้ (0 or 1)          |
| {n}        | n ตัวเป๊ะๆ                         |
| {m,n}      | m - n ตัว                         |
| {n,}       | อย่างน้อย n ตัว                     |
| {,n}       | อย่างมาก n ตัว                     |

ตัวอย่าง

| regex | แปลว่า | ตัวอย่างที่แมทช์ |  
| ----- | ------ | --- | 
| \d+   | ตัวเลขอย่างน้อยหนึ่งตัว | 1113333 
| [ก-ฮ]{2} \d{4} | ตัวอักษรไทย 2 ตัว ตามด้วยตัวเลข 4 ตัว (เลขทะเบียนรถ) |  ตอ 6465 |

# Regular expression ในภาษาไพธอน
คำสั่งที่เกี่ยวกับ regular expression อยู่ในโมดูล `re` ของไพธอน คำสั่งที่จำเป็นต้องทราบสำหรับการใช้ regular expression มีอยู่ 5 คำสั่ง

| ฟังก์ชัน  | จุดประสงค์การใช้ | 
|--------|--------------|
| `re.match` | ตรวจสอบว่า regex match กับต้นสตริงหรือไม่ | 
| `re.search` | ตรวจสอบว่า regex match กับส่วนใดส่วนหนึ่งของสตริงหรือไม่ | 
| `re.findall` | หาส่วนที่ regex match ทั้งหมด
| `re.sub` | แทนที่ส่วนที่ regex match ด้วยสตริงอีกสตริงหนึ่ง 
| `re.split` | หั่นสตริงออกเป็นลิสต์ โดยใช้ regex เป็นตัวบ่งบอกส่วนที่ใช้หั่นสตริง 

## re.match 
คำสั่งนี้ต้องการ regular expression ที่บ่งบอกแพทเทิร์น และสตริงที่ต้องการจะตรวจสอบ 
```python
import re
match = re.match('นาย([ก-์]+)พล ([ก-์]+)', 'นายณัฐพล โคกสูงเนิน')
if not match:
    print ('ชื่อไม่แมทช์กับแพทเทิร์นนี้')
```
คำสั่ง `re.match` จะรีเทิร์น match object กลับมาให้ถ้าหากแพทเทิร์นแมทช์กับสตริงที่ระบุไว้ ถ้าหากไม่เราจะได้ `None` คืนกลับมาแทน 

ถ้าหากเราต้องการทราบด้วยว่าแพทเทิร์นไป match ส่วนใดของสตริงบ้าง เราต้องใช้ match object ที่รีิเทิร์นมา ซึ่งมี method ที่ควรทราบคือ `.group`
```python
import re
match = re.match('นาย([ก-์]+)พล ([ก-์]+)', 'นายณัฐพล โคกสูงเนิน')
if not match:
    print ('ชื่อไม่แมทช์กับแพทเทิร์นนี้')
else:
    print (match.group(0)) # นายณัฐพล โคกสูงเนิน
    print (match.group(1)) # ณัฐ
    print (match.group(2)) # โคกสูงเนิน
```
ข้อสังเกตแรกคือเราใช้ `()` ใน regex ข้างต้นเพื่อเป็นการจัดกลุ่มที่เราสามารถอ้างถึงได้ภายหลังด้วยคำสั่ง `.group` โดย group ที่ 0 จะอ้างถึงทั้งแพทเทิร์น ส่วน group ต่อ ๆ มาจะเรียงจากซ้ายไปขวา 

## re.search
คล้ายกับ `re.match` ทุกอย่างเพียงแต่ว่าจะสแกนหาทั้งสตริงว่าแพทเทิร์นไปแมทช์กับส่วนใดส่วนหนึ่งของสตริงหรือไม่ ไม่ได้จำกัดแค่ตัวอักษรแรกของสตริงเหมือนกับ `.match` 

```python
import re
match = re.match('นาย([ก-์]+)พล ([ก-์]+)', 'ได้เข้าพบนายณัฐพล โคกสูงเนิน') # None เพราะไม่มีแมทช์ตั้งแต่ต้นสตริง
match = re.search('นาย([ก-์]+)พล ([ก-์]+)', 'ได้เข้าพบนายณัฐพล โคกสูงเนิน') # match 
print (match.group(0)) # นายณัฐพล โคกสูงเนิน
print (match.group(1)) # ณัฐ
print (match.group(2)) # โคกสูงเนิน
```
match object ที่รีเทิร์นกลับมามีวิธีการใช้เช่นเดิม

## re.findall

```python
import re
pattern = '\w+s'
sentence = 'James misses the stitches that Carlos fixes'
s_words = re.findall(pattern, sentence)
s_words # --> ['James', 'misses', 'stitches', 'Carlos', 'fixes']
```

ถ้าหาก regex มีการใช้ `()` หนึ่งครั้ง เรารีเทิร์นมาเฉพาะส่วนที่อยู่ใน `()` เท่านั้น เช่น
```python
import re
pattern = '\w+(x|tch|sh|z|s)es'
sentence = 'James misses the stitches that Carlos fixes'
es_words = re.findall(pattern, sentence)
es_words # --> ['s', 'tch', 'x']
```
ถ้าหาก regex มีการใช้ `()` มากกว่าหนึ่งครั้ง เรารีเทิร์นมาทุกกลุ่ม กลายเป็นลิสต์ขของทูเปิล เช่น

```python
import re
pattern = '(\w+(x|tch|sh|z|s)es)'
sentence = 'James misses the stitches that Carlos fixes'
es_words = re.findall(pattern, sentence)
es_words # --> [('misses', 's'), ('stitches', 'tch'), ('fixes', 'x')]
```
## re.sub


## re.split
